<html><head><link rel="stylesheet" href="../docs_style.css"></head><div class="decl"><h4>fin2</h4><div class="decl_par"><p>An alternate definition of <span style="background-color:#fdf6e3;color:#657b83;">fin n</span> defined as an inductive type
instead of a subtype of <span style="background-color:#fdf6e3;color:#657b83;">nat</span>. This is useful for its induction
principle and different definitional equalities.</p>
</div></div><div class="decl"><h4>fin2.to_nat</h4><div class="decl_par"><p>convert a <span style="background-color:#fdf6e3;color:#657b83;">fin2</span> into a <span style="background-color:#fdf6e3;color:#657b83;">nat</span></p>
</div></div><div class="decl"><h4>fin2.opt_of_nat</h4><div class="decl_par"><p>convert a <span style="background-color:#fdf6e3;color:#657b83;">nat</span> into a <span style="background-color:#fdf6e3;color:#657b83;">fin2</span> if it is in range</p>
</div></div><div class="decl"><h4>fin2.add</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">i </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> k : fin2 (n </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> k)</span> when <span style="background-color:#fdf6e3;color:#657b83;">i : fin2 n</span> and <span style="background-color:#fdf6e3;color:#657b83;">k : ℕ</span></p>
</div></div><div class="decl"><h4>fin2.left</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">left k</span> is the embedding <span style="background-color:#fdf6e3;color:#657b83;">fin2 n </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> fin2 (k </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> n)</span></p>
</div></div><div class="decl"><h4>fin2.insert_perm</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">insert_perm a</span> is a permutation of <span style="background-color:#fdf6e3;color:#657b83;">fin2 n</span> with the following properties:</p>
<ul>
<li><span style="background-color:#fdf6e3;color:#657b83;">insert_perm a i </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> i</span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#6c71c4;">1</span> if <span style="background-color:#fdf6e3;color:#657b83;">i </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> a</span></li>
<li><span style="background-color:#fdf6e3;color:#657b83;">insert_perm a a </span><span style="background-color:#fdf6e3;color:#b58900;">= </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span></li>
<li><span style="background-color:#fdf6e3;color:#657b83;">insert_perm a i </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> i</span> if <span style="background-color:#fdf6e3;color:#657b83;">i </span><span style="background-color:#fdf6e3;color:#b58900;">&gt;</span><span style="background-color:#fdf6e3;color:#657b83;"> a</span></li>
</ul>
</div></div><div class="decl"><h4>fin2.remap_left</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">remap_left f k : fin2 (m </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> k) </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> fin2 (n </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> k)</span> applies the function
<span style="background-color:#fdf6e3;color:#657b83;">f : fin2 m </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> fin2 n</span> to inputs less than <span style="background-color:#fdf6e3;color:#657b83;">m</span>, and leaves the right part
on the right (that is, <span style="background-color:#fdf6e3;color:#657b83;">remap_left f k (m </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> i) </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> n </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> i</span>).</p>
</div></div><div class="decl"><h4>fin2.is_lt</h4><div class="decl_par"><p>This is a simple type class inference prover for proof obligations
of the form <span style="background-color:#fdf6e3;color:#657b83;">m </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> n</span> where <span style="background-color:#fdf6e3;color:#657b83;">m n : ℕ</span>.</p>
</div></div><div class="decl"><h4>fin2.of_nat'</h4><div class="decl_par"><p>Use type class inference to infer the boundedness proof, so that we
can directly convert a <span style="background-color:#fdf6e3;color:#657b83;">nat</span> into a <span style="background-color:#fdf6e3;color:#657b83;">fin2 n</span>. This supports
notation like <span style="background-color:#fdf6e3;color:#657b83;">&amp;</span><span style="background-color:#fdf6e3;color:#6c71c4;">1</span><span style="background-color:#fdf6e3;color:#657b83;"> : fin </span><span style="background-color:#fdf6e3;color:#6c71c4;">3</span>.</p>
</div></div><div class="decl"><h4>vector3</h4><div class="decl_par"><p>Alternate definition of <span style="background-color:#fdf6e3;color:#657b83;">vector</span> based on <span style="background-color:#fdf6e3;color:#657b83;">fin2</span>.</p>
</div></div><div class="decl"><h4>vector3.nil</h4><div class="decl_par"><p>The empty vector</p>
</div></div><div class="decl"><h4>vector3.cons</h4><div class="decl_par"><p>The vector cons operation</p>
</div></div><div class="decl"><h4>vector3.nth</h4><div class="decl_par"><p>Get the <span style="background-color:#fdf6e3;color:#657b83;">i</span>th element of a vector</p>
</div></div><div class="decl"><h4>vector3.of_fn</h4><div class="decl_par"><p>Construct a vector from a function on <span style="background-color:#fdf6e3;color:#657b83;">fin2</span>.</p>
</div></div><div class="decl"><h4>vector3.head</h4><div class="decl_par"><p>Get the head of a nonempty vector.</p>
</div></div><div class="decl"><h4>vector3.tail</h4><div class="decl_par"><p>Get the tail of a nonempty vector.</p>
</div></div><div class="decl"><h4>vector3.append</h4><div class="decl_par"><p>Append two vectors</p>
</div></div><div class="decl"><h4>vector3.insert</h4><div class="decl_par"><p>Insert <span style="background-color:#fdf6e3;color:#657b83;">a</span> into <span style="background-color:#fdf6e3;color:#657b83;">v</span> at index <span style="background-color:#fdf6e3;color:#657b83;">i</span>.</p>
</div></div><div class="decl"><h4>vector_ex</h4><div class="decl_par"><p>&quot;Curried&quot; exists, i.e. ∃ x1 ... xn, f [x1, ..., xn]</p>
</div></div><div class="decl"><h4>vector_all</h4><div class="decl_par"><p>&quot;Curried&quot; forall, i.e. ∀ x1 ... xn, f [x1, ..., xn]</p>
</div></div><div class="decl"><h4>vector_allp</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">vector_allp p v</span> is equivalent to <span style="background-color:#fdf6e3;color:#657b83;">∀ i, p (v i)</span>, but unfolds directly to a conjunction,
i.e. <span style="background-color:#fdf6e3;color:#657b83;">vector_allp p [</span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span><span style="background-color:#fdf6e3;color:#657b83;">, </span><span style="background-color:#fdf6e3;color:#6c71c4;">1</span><span style="background-color:#fdf6e3;color:#657b83;">, </span><span style="background-color:#fdf6e3;color:#6c71c4;">2</span><span style="background-color:#fdf6e3;color:#657b83;">] </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> p </span><span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> p </span><span style="background-color:#fdf6e3;color:#6c71c4;">1 </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> p </span><span style="background-color:#fdf6e3;color:#6c71c4;">2</span>.</p>
</div></div><div class="decl"><h4>list_all</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">list_all p l</span> is equivalent to <span style="background-color:#fdf6e3;color:#657b83;">∀ a ∈ l, p a</span>, but unfolds directly to a conjunction,
i.e. <span style="background-color:#fdf6e3;color:#657b83;">list_all p [</span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span><span style="background-color:#fdf6e3;color:#657b83;">, </span><span style="background-color:#fdf6e3;color:#6c71c4;">1</span><span style="background-color:#fdf6e3;color:#657b83;">, </span><span style="background-color:#fdf6e3;color:#6c71c4;">2</span><span style="background-color:#fdf6e3;color:#657b83;">] </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> p </span><span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> p </span><span style="background-color:#fdf6e3;color:#6c71c4;">1 </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> p </span><span style="background-color:#fdf6e3;color:#6c71c4;">2</span>.</p>
</div></div><div class="decl"><h4>is_poly</h4><div class="decl_par"><p>A predicate asserting that a function is a multivariate integer polynomial.
(We are being a bit lazy here by allowing many representations for multiplication,
rather than only allowing monomials and addition, but the definition is equivalent
and this is easier to use.)</p>
</div></div><div class="decl"><h4>poly</h4><div class="decl_par"><p>The type of multivariate integer polynomials</p>
</div></div><div class="decl"><h4>poly.isp</h4><div class="decl_par"><p>The underlying function of a <span style="background-color:#fdf6e3;color:#657b83;">poly</span> is a polynomial</p>
</div></div><div class="decl"><h4>poly.ext</h4><div class="decl_par"><p>Extensionality for <span style="background-color:#fdf6e3;color:#657b83;">poly α</span></p>
</div></div><div class="decl"><h4>poly.subst</h4><div class="decl_par"><p>Construct a <span style="background-color:#fdf6e3;color:#657b83;">poly</span> given an extensionally equivalent <span style="background-color:#fdf6e3;color:#657b83;">poly</span>.</p>
</div></div><div class="decl"><h4>poly.proj</h4><div class="decl_par"><p>The <span style="background-color:#fdf6e3;color:#657b83;">i</span>th projection function, <span style="background-color:#fdf6e3;color:#657b83;">x_i</span>.</p>
</div></div><div class="decl"><h4>poly.const</h4><div class="decl_par"><p>The constant function with value <span style="background-color:#fdf6e3;color:#657b83;">n : ℤ</span>.</p>
</div></div><div class="decl"><h4>poly.zero</h4><div class="decl_par"><p>The zero polynomial</p>
</div></div><div class="decl"><h4>poly.one</h4><div class="decl_par"><p>The zero polynomial</p>
</div></div><div class="decl"><h4>poly.sub</h4><div class="decl_par"><p>Subtraction of polynomials</p>
</div></div><div class="decl"><h4>poly.neg</h4><div class="decl_par"><p>Negation of a polynomial</p>
</div></div><div class="decl"><h4>poly.add</h4><div class="decl_par"><p>Addition of polynomials</p>
</div></div><div class="decl"><h4>poly.mul</h4><div class="decl_par"><p>Multiplication of polynomials</p>
</div></div><div class="decl"><h4>poly.sumsq</h4><div class="decl_par"><p>The sum of squares of a list of polynomials. This is relevant for
Diophantine equations, because it means that a list of equations
can be encoded as a single equation: <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">= </span><span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> y </span><span style="background-color:#fdf6e3;color:#b58900;">= </span><span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> z </span><span style="background-color:#fdf6e3;color:#b58900;">= </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span> is
equivalent to <span style="background-color:#fdf6e3;color:#657b83;">x^</span><span style="background-color:#fdf6e3;color:#6c71c4;">2 </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> y^</span><span style="background-color:#fdf6e3;color:#6c71c4;">2 </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> z^</span><span style="background-color:#fdf6e3;color:#6c71c4;">2 </span><span style="background-color:#fdf6e3;color:#b58900;">= </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span>.</p>
</div></div><div class="decl"><h4>poly.remap</h4><div class="decl_par"><p>Map the index set of variables, replacing <span style="background-color:#fdf6e3;color:#657b83;">x_i</span> with <span style="background-color:#fdf6e3;color:#657b83;">x_(f i)</span>.</p>
</div></div><div class="decl"><h4>sum.join</h4><div class="decl_par"><p>combine two functions into a function on the disjoint union</p>
</div></div><div class="decl"><h4>option.cons</h4><div class="decl_par"><p>Functions from <span style="background-color:#fdf6e3;color:#657b83;">option</span> can be combined similarly to <span style="background-color:#fdf6e3;color:#657b83;">vector.cons</span></p>
</div></div><div class="decl"><h4>dioph</h4><div class="decl_par"><p>A set <span style="background-color:#fdf6e3;color:#657b83;">S ⊆ ℕ^α</span> is diophantine if there exists a polynomial on
<span style="background-color:#fdf6e3;color:#657b83;">α ⊕ β</span> such that <span style="background-color:#fdf6e3;color:#657b83;">v ∈ S</span> iff there exists <span style="background-color:#fdf6e3;color:#657b83;">t : ℕ^β</span> with <span style="background-color:#fdf6e3;color:#657b83;">p (v, t) </span><span style="background-color:#fdf6e3;color:#b58900;">= </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span>.</p>
</div></div><div class="decl"><h4>dioph.dioph_pfun</h4><div class="decl_par"><p>A partial function is Diophantine if its graph is Diophantine.</p>
</div></div><div class="decl"><h4>dioph.dioph_fn</h4><div class="decl_par"><p>A function is Diophantine if its graph is Diophantine.</p>
</div></div></html>