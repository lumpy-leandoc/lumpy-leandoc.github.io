<html><head><link rel="stylesheet" href="../docs_style.css"></head><p>This file provides an alternative implementation for <span style="background-color:#fdf6e3;color:#657b83;">apply</span> to fix the so-called &quot;apply bug&quot;.</p>
<p>The issue arises when the goals is a Π-type -- whether it is visible or hidden behind a definition.</p>
<p>For instance, consider the following proof:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">example</span><span style="color:#657b83;"> {α β} (x y z : α </span><span style="color:#859900;">→</span><span style="color:#657b83;"> β) (h₀ : x </span><span style="color:#b58900;">≤</span><span style="color:#657b83;"> y) (h₁ : y </span><span style="color:#b58900;">≤</span><span style="color:#657b83;"> z) : x </span><span style="color:#b58900;">≤</span><span style="color:#657b83;"> z </span><span style="color:#b58900;">:=
</span><span style="color:#859900;">begin
</span><span style="color:#657b83;">  apply le_trans,
</span><span style="color:#859900;">end
</span></pre>
</code></pre>
<p>Because <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> z</span> is definitionally equal to <span style="background-color:#fdf6e3;color:#657b83;">∀ i, x i </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> z i</span>, <span style="background-color:#fdf6e3;color:#657b83;">apply</span> will fail. The alternative definition,
<span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> fixes this. When <span style="background-color:#fdf6e3;color:#657b83;">apply</span> would work, <span style="background-color:#fdf6e3;color:#657b83;">apply</span> is used and otherwise, a different strategy is deployed</p>
<hr/><div class="decl"><h4>tactic.reorder_goals</h4><div class="decl_par"><p>With <span style="background-color:#fdf6e3;color:#657b83;">gs</span> a list of proof goals, <span style="background-color:#fdf6e3;color:#657b83;">reorder_goals gs new_g</span> will use the <span style="background-color:#fdf6e3;color:#657b83;">new_goals</span> policy <span style="background-color:#fdf6e3;color:#657b83;">new_g</span> to rearrange the
dependent goals to either drop them, push them to the end of the list or leave them in place. The <span style="background-color:#fdf6e3;color:#657b83;">bool</span> values in
<span style="background-color:#fdf6e3;color:#657b83;">gs</span> indicates whether the goal is dependent or not.</p>
</div></div><div class="decl"><h4>tactic.apply'</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> mimics the behavior of <span style="background-color:#fdf6e3;color:#657b83;">apply_core</span>. When
<span style="background-color:#fdf6e3;color:#657b83;">apply_core</span> fails, it is retried by providing the term with meta
variables as additional arguments. The meta variables can then
become new goals depending on the <span style="background-color:#fdf6e3;color:#657b83;">cfg.new_goals</span> policy.</p>
<p><span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> also finds instances and applies opt_params and auto_params.</p>
</div></div><div class="decl"><h4>tactic.fapply'</h4><div class="decl_par"><p>Same as <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> but <strong>all</strong> arguments that weren't inferred are added to goal list.</p>
</div></div><div class="decl"><h4>tactic.eapply'</h4><div class="decl_par"><p>Same as <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> but only goals that don't depend on other goals are added to goal list.</p>
</div></div><div class="decl"><h4>_private.3298545957.relation_tactic</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">relation_tactic</span> finds a proof rule for the relation found in the goal and uses <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> to make one proof step.</p>
</div></div><div class="decl"><h4>tactic.reflexivity'</h4><div class="decl_par"><p>Similar to <span style="background-color:#fdf6e3;color:#657b83;">reflexivity</span> with the difference that <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> is used instead of <span style="background-color:#fdf6e3;color:#657b83;">apply</span></p>
</div></div><div class="decl"><h4>tactic.symmetry'</h4><div class="decl_par"><p>Similar to <span style="background-color:#fdf6e3;color:#657b83;">symmetry</span> with the difference that <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> is used instead of <span style="background-color:#fdf6e3;color:#657b83;">apply</span></p>
</div></div><div class="decl"><h4>tactic.transitivity'</h4><div class="decl_par"><p>Similar to <span style="background-color:#fdf6e3;color:#657b83;">transitivity</span> with the difference that <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> is used instead of <span style="background-color:#fdf6e3;color:#657b83;">apply</span></p>
</div></div><div class="decl"><h4>tactic.interactive.apply'</h4><div class="decl_par"><p>Similarly to <span style="background-color:#fdf6e3;color:#657b83;">apply</span>, the <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> tactic tries to match the current goal against the conclusion of the type of term.</p>
<p>It differs from <span style="background-color:#fdf6e3;color:#657b83;">apply</span> in that it does not unfold definition in order to find out what the assumptions of the provided term is. It is especially useful when defining relations on function spaces (e.g. <span style="background-color:#fdf6e3;color:#b58900;">≤</span>) so that rules like transitivity on <span style="background-color:#fdf6e3;color:#657b83;">le : (α </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> β) </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> (α </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> β) </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> (α </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> β)</span> will be considered to have three parameters and two assumptions (i.e. <span style="background-color:#fdf6e3;color:#657b83;">f g h : α </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> β</span>, <span style="background-color:#fdf6e3;color:#657b83;">H₀ : f </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> g</span>, <span style="background-color:#fdf6e3;color:#657b83;">H₁ : g </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> h</span>) instead of three parameters, two assumptions and then one more parameter (i.e. <span style="background-color:#fdf6e3;color:#657b83;">f g h : α </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> β</span>, <span style="background-color:#fdf6e3;color:#657b83;">H₀ : f </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> g</span>, <span style="background-color:#fdf6e3;color:#657b83;">H₁ : g </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> h</span>, <span style="background-color:#fdf6e3;color:#657b83;">x : α</span>). Whereas <span style="background-color:#fdf6e3;color:#657b83;">apply</span> would expect the goal <span style="background-color:#fdf6e3;color:#657b83;">f x </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> h x</span>, <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> will work with the goal <span style="background-color:#fdf6e3;color:#657b83;">f </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> h</span>.</p>
</div></div><div class="decl"><h4>tactic.interactive.fapply'</h4><div class="decl_par"><p>Similar to the <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> tactic, but does not reorder goals.</p>
</div></div><div class="decl"><h4>tactic.interactive.eapply'</h4><div class="decl_par"><p>Similar to the <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> tactic, but only creates subgoals for non-dependent premises that have not been fixed by type inference or type class resolution.</p>
</div></div><div class="decl"><h4>tactic.interactive.apply_with'</h4><div class="decl_par"><p>Similar to the <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> tactic, but allows the user to provide a <span style="background-color:#fdf6e3;color:#657b83;">apply_cfg</span> configuration object.</p>
</div></div><div class="decl"><h4>tactic.interactive.mapply'</h4><div class="decl_par"><p>Similar to the <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> tactic, but uses matching instead of unification.
<span style="background-color:#fdf6e3;color:#657b83;">mapply&#39; t</span> is equivalent to <span style="background-color:#fdf6e3;color:#657b83;">apply_with&#39; t {unify </span><span style="background-color:#fdf6e3;color:#b58900;">:=</span><span style="background-color:#fdf6e3;color:#657b83;"> ff}</span></p>
</div></div><div class="decl"><h4>tactic.interactive.reflexivity'</h4><div class="decl_par"><p>Similar to <span style="background-color:#fdf6e3;color:#657b83;">reflexivity</span> with the difference that <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> is used instead of <span style="background-color:#fdf6e3;color:#657b83;">apply</span>.</p>
</div></div><div class="decl"><h4>tactic.interactive.refl'</h4><div class="decl_par"><p>Shorter name for the tactic <span style="background-color:#fdf6e3;color:#657b83;">reflexivity&#39;</span>.</p>
</div></div><div class="decl"><h4>tactic.interactive.symmetry'</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">symmetry&#39;</span> behaves like <span style="background-color:#fdf6e3;color:#657b83;">symmetry</span> but also offers the option <span style="background-color:#fdf6e3;color:#657b83;">symmetry&#39; </span><span style="background-color:#fdf6e3;color:#859900;">at</span><span style="background-color:#fdf6e3;color:#657b83;"> h</span> to apply symmetry to assumption <span style="background-color:#fdf6e3;color:#657b83;">h</span></p>
</div></div><div class="decl"><h4>tactic.interactive.transitivity'</h4><div class="decl_par"><p>Similar to <span style="background-color:#fdf6e3;color:#657b83;">transitivity</span> with the difference that <span style="background-color:#fdf6e3;color:#657b83;">apply&#39;</span> is used instead of <span style="background-color:#fdf6e3;color:#657b83;">apply</span>.</p>
</div></div></html>