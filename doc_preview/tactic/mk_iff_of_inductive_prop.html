<html><head><link rel="stylesheet" href="../docs_style.css"></head><div class="decl"><h4>_private.2974432217.compact_relation</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">compact_relation bs as_ps</span>: Produce a relation of the form:
R as := ∃ bs, Λ_i a_i = p_i[bs]
This relation is user visible, so we compact it by removing each <span style="background-color:#fdf6e3;color:#657b83;">b_j</span> where a <span style="background-color:#fdf6e3;color:#657b83;">p_i </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> b_j</span>, and
hence <span style="background-color:#fdf6e3;color:#657b83;">a_i </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> b_j</span>. We need to take care when there are <span style="background-color:#fdf6e3;color:#657b83;">p_i</span> and <span style="background-color:#fdf6e3;color:#657b83;">p_j</span> with <span style="background-color:#fdf6e3;color:#657b83;">p_i </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> p_j </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> b_k</span>.</p>
<p>TODO: this is copied from Lean's <span style="background-color:#fdf6e3;color:#657b83;">coinductive_predicates.lean</span>, export it there.</p>
</div></div><div class="decl"><h4>tactic.mk_iff_of_inductive_prop</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">mk_iff_of_inductive_prop i r</span> makes a iff rule for the inductively defined proposition <span style="background-color:#fdf6e3;color:#657b83;">i</span>.
The new rule <span style="background-color:#fdf6e3;color:#657b83;">r</span> has the shape <span style="background-color:#fdf6e3;color:#657b83;">∀ps is, i </span><span style="background-color:#fdf6e3;color:#859900;">as </span><span style="background-color:#fdf6e3;color:#b58900;">↔</span><span style="background-color:#fdf6e3;color:#657b83;"> ⋁_j, ∃cs, is </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> cs</span>, where <span style="background-color:#fdf6e3;color:#657b83;">ps</span> are the type
parameters, <span style="background-color:#fdf6e3;color:#657b83;">is</span> are the indices, <span style="background-color:#fdf6e3;color:#657b83;">j</span> ranges over all possible constructors, the <span style="background-color:#fdf6e3;color:#657b83;">cs</span> are the
parameters for each constructors, the equalities <span style="background-color:#fdf6e3;color:#657b83;">is </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> cs</span> are the instantiations for each
constructor for each of the indices to the inductive type <span style="background-color:#fdf6e3;color:#657b83;">i</span>.</p>
<p>In each case, we remove constructor parameters (i.e. <span style="background-color:#fdf6e3;color:#657b83;">cs</span>) when the corresponding equality would
be just <span style="background-color:#fdf6e3;color:#657b83;">c </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> i</span> for some index <span style="background-color:#fdf6e3;color:#657b83;">i</span>.</p>
<p>For example: <span style="background-color:#fdf6e3;color:#657b83;">mk_iff_of_inductive_prop</span> on <span style="background-color:#fdf6e3;color:#657b83;">list.chain</span> produces:</p>
<p>∀{α : Type*} (R : α → α → Prop) (a : α) (l : list α),
chain R a l ↔ l = [] ∨ ∃{b : α} {l' : list α}, R a b ∧ chain R b l ∧ l = b :: l'</p>
</div></div></html>