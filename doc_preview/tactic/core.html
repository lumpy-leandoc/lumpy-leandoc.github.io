<html><head><link rel="stylesheet" href="../docs_style.css"></head><div class="decl"><h4>expr.of_nat</h4><div class="decl_par"><p>Given an expr <span style="background-color:#fdf6e3;color:#657b83;">α</span> representing a type with numeral structure,
<span style="background-color:#fdf6e3;color:#657b83;">of_nat α n</span> creates the <span style="background-color:#fdf6e3;color:#657b83;">α</span>-valued numeral expression corresponding to <span style="background-color:#fdf6e3;color:#657b83;">n</span>.</p>
</div></div><div class="decl"><h4>expr.of_int</h4><div class="decl_par"><p>Given an expr <span style="background-color:#fdf6e3;color:#657b83;">α</span> representing a type with numeral structure,
<span style="background-color:#fdf6e3;color:#657b83;">of_nat α n</span> creates the <span style="background-color:#fdf6e3;color:#657b83;">α</span>-valued numeral expression corresponding to <span style="background-color:#fdf6e3;color:#657b83;">n</span>.
The output is either a numeral or the negation of a numeral.</p>
</div></div><div class="decl"><h4>expr.mk_exists_lst</h4><div class="decl_par"><p>Generates an expression of the form <span style="background-color:#fdf6e3;color:#657b83;">∃(args), inner</span>. <span style="background-color:#fdf6e3;color:#657b83;">args</span> is assumed to be a list of local
constants. When possible, <span style="background-color:#fdf6e3;color:#657b83;">p </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> q</span> is used instead of <span style="background-color:#fdf6e3;color:#657b83;">∃(_ : p), q</span>.</p>
</div></div><div class="decl"><h4>expr.traverse</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">traverse f e</span> applies the monadic function <span style="background-color:#fdf6e3;color:#657b83;">f</span> to the direct descendants of <span style="background-color:#fdf6e3;color:#657b83;">e</span>.</p>
</div></div><div class="decl"><h4>expr.mfoldl</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">mfoldl f a e</span> folds the monadic function <span style="background-color:#fdf6e3;color:#657b83;">f</span> over the subterms of the expression <span style="background-color:#fdf6e3;color:#657b83;">e</span>,
with initial value <span style="background-color:#fdf6e3;color:#657b83;">a</span>.</p>
</div></div><div class="decl"><h4>interaction_monad.get_result</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">get_result tac</span> returns the result state of applying <span style="background-color:#fdf6e3;color:#657b83;">tac</span> to the current state.
Note that it does not update the current state.</p>
</div></div><div class="decl"><h4>lean.parser.of_tactic'</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">of_tactic&#39; tac</span> lifts the tactic <span style="background-color:#fdf6e3;color:#657b83;">tac</span> into the parser monad.
This replaces <span style="background-color:#fdf6e3;color:#657b83;">of_tactic</span> in core, which has a buggy implementation.</p>
</div></div><div class="decl"><h4>lean.parser.has_coe'</h4><div class="decl_par"><p>Override the builtin <span style="background-color:#fdf6e3;color:#657b83;">lean.parser.of_tactic</span> coe, which is broken.
(See test/tactics.lean for a failure case.)</p>
</div></div><div class="decl"><h4>lean.parser.emit_command_here</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">emit_command_here str</span> behaves as if the string <span style="background-color:#fdf6e3;color:#657b83;">str</span> were placed as a user command at the
current line.</p>
</div></div><div class="decl"><h4>lean.parser.emit_code_here</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">emit_code_here str</span> behaves as if the string <span style="background-color:#fdf6e3;color:#657b83;">str</span> were placed at the current location in
source code.</p>
</div></div><div class="decl"><h4>format.intercalate</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">intercalate x [a, b, c]</span> produces the format object <span style="background-color:#fdf6e3;color:#657b83;">a.x.b.x.c</span>,
where <span style="background-color:#fdf6e3;color:#657b83;">.</span> represents <span style="background-color:#fdf6e3;color:#657b83;">format.join</span>.</p>
</div></div><div class="decl"><h4>tactic.eval_expr'</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">eval_expr&#39; α e</span> attempts to evaluate the expression <span style="background-color:#fdf6e3;color:#657b83;">e</span> in the type <span style="background-color:#fdf6e3;color:#657b83;">α</span>.
This is a variant of <span style="background-color:#fdf6e3;color:#657b83;">eval_expr</span> in core. Due to unexplained behavior in the VM, in rare
situations the latter will fail but the former will succeed.</p>
</div></div><div class="decl"><h4>tactic.mk_user_fresh_name</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">mk_fresh_name</span> returns identifiers starting with underscores,
which are not legal when emitted by tactic programs. <span style="background-color:#fdf6e3;color:#657b83;">mk_user_fresh_name</span> turns the
useful source of random names provided by <span style="background-color:#fdf6e3;color:#657b83;">mk_fresh_name</span> into
names which are usable by tactic programs.</p>
<p>The returned name has four components which are all strings.</p>
</div></div><div class="decl"><h4>tactic.has_attribute'</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">has_attribute n n&#39;</span> checks whether n' has attribute n.</p>
</div></div><div class="decl"><h4>tactic.is_simp_lemma</h4><div class="decl_par"><p>Checks whether the name is a simp lemma</p>
</div></div><div class="decl"><h4>tactic.is_instance</h4><div class="decl_par"><p>Checks whether the name is an instance.</p>
</div></div><div class="decl"><h4>tactic.local_decls</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">local_decls</span> returns a dictionary mapping names to their corresponding declarations.
Covers all declarations from the current file.</p>
</div></div><div class="decl"><h4>tactic.get_unused_decl_name_aux</h4><div class="decl_par"><p>If <span style="background-color:#fdf6e3;color:#657b83;">{nm}_{n}</span> doesn't exist in the environment, returns that, otherwise tries <span style="background-color:#fdf6e3;color:#657b83;">{nm}_{n</span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#6c71c4;">1</span><span style="background-color:#fdf6e3;color:#657b83;">}</span></p>
</div></div><div class="decl"><h4>tactic.get_unused_decl_name</h4><div class="decl_par"><p>Return a name which doesn't already exist in the environment. If <span style="background-color:#fdf6e3;color:#657b83;">nm</span> doesn't exist, it
returns that, otherwise it tries nm_2, nm_3, ...</p>
</div></div><div class="decl"><h4>tactic.decl_mk_const</h4><div class="decl_par"><p>Returns a pair (e, t), where <span style="background-color:#fdf6e3;color:#657b83;">e ← mk_const d.to_name</span>, and <span style="background-color:#fdf6e3;color:#657b83;">t </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> d.type</span>
but with universe params updated to match the fresh universe metavariables in <span style="background-color:#fdf6e3;color:#657b83;">e</span>.</p>
<p>This should have the same effect as just</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">do</span><span style="color:#657b83;"> e ← mk_const d.to_name,
</span><span style="color:#657b83;">   t ← infer_type e,
</span><span style="color:#657b83;">   return (e, t)
</span></pre>
</code></pre>
<p>but is hopefully faster.</p>
</div></div><div class="decl"><h4>tactic.mk_local</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">mk_local n</span> creates a dummy local variable with name <span style="background-color:#fdf6e3;color:#657b83;">n</span>.
The type of this local constant is a constant with name <span style="background-color:#fdf6e3;color:#657b83;">n</span>, so it is very unlikely to be
a meaningful expression.</p>
</div></div><div class="decl"><h4>tactic.local_def_value</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">local_def_value e</span> returns the value of the expression <span style="background-color:#fdf6e3;color:#657b83;">e</span>, assuming that <span style="background-color:#fdf6e3;color:#657b83;">e</span> has been defined
locally using a <span style="background-color:#fdf6e3;color:#859900;">let</span> expression. Otherwise it fails.</p>
</div></div><div class="decl"><h4>tactic.check_defn</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">check_defn n e</span> elaborates the pre-expression <span style="background-color:#fdf6e3;color:#657b83;">e</span>,
and succeeds if this is alpha-equivalent to the value of the declaration with name <span style="background-color:#fdf6e3;color:#657b83;">n</span>.</p>
</div></div><div class="decl"><h4>tactic.pis</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">pis loc_consts f</span> is used to create a pi expression whose body is <span style="background-color:#fdf6e3;color:#657b83;">f</span>.
<span style="background-color:#fdf6e3;color:#657b83;">loc_consts</span> should be a list of local constants. The function will abstract these local
constants from <span style="background-color:#fdf6e3;color:#657b83;">f</span> and bind them with pi binders.</p>
<p>For example, if <span style="background-color:#fdf6e3;color:#657b83;">a, b</span> are local constants with types <span style="background-color:#fdf6e3;color:#657b83;">Ta, Tb</span>,
<span style="background-color:#fdf6e3;color:#657b83;">pis [a, b] `(f a b)</span> will return the expression
<span style="background-color:#fdf6e3;color:#657b83;">Π (a : Ta) (b : Tb), f a b</span></p>
</div></div><div class="decl"><h4>tactic.lambdas</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">lambdas loc_consts f</span> is used to create a lambda expression whose body is <span style="background-color:#fdf6e3;color:#657b83;">f</span>.
<span style="background-color:#fdf6e3;color:#657b83;">loc_consts</span> should be a list of local constants. The function will abstract these local
constants from <span style="background-color:#fdf6e3;color:#657b83;">f</span> and bind them with lambda binders.</p>
<p>For example, if <span style="background-color:#fdf6e3;color:#657b83;">a, b</span> are local constants with types <span style="background-color:#fdf6e3;color:#657b83;">Ta, Tb</span>,
<span style="background-color:#fdf6e3;color:#657b83;">lambdas [a, b] `(f a b)</span> will return the expression
<span style="background-color:#fdf6e3;color:#657b83;">λ (a : Ta) (b : Tb), f a b</span></p>
</div></div><div class="decl"><h4>tactic.extract_def</h4><div class="decl_par"><p>Given <span style="background-color:#fdf6e3;color:#657b83;">elab_def</span>, a tactic to solve the current goal,
<span style="background-color:#fdf6e3;color:#657b83;">extract_def n trusted elab_def</span> will create an auxiliary definition named <span style="background-color:#fdf6e3;color:#657b83;">n</span> and use it
to close the goal. If <span style="background-color:#fdf6e3;color:#657b83;">trusted</span> is false, it will be a meta definition.</p>
</div></div><div class="decl"><h4>tactic.exact_dec_trivial</h4><div class="decl_par"><p>Attempts to close the goal with <span style="background-color:#fdf6e3;color:#657b83;">dec_trivial</span>.</p>
</div></div><div class="decl"><h4>tactic.retrieve</h4><div class="decl_par"><p>Runs a tactic for a result, reverting the state after completion</p>
</div></div><div class="decl"><h4>tactic.repeat1</h4><div class="decl_par"><p>Repeat a tactic at least once, calling it recursively on all subgoals,
until it fails. This tactic fails if the first invocation fails.</p>
</div></div><div class="decl"><h4>tactic.iterate_range</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">iterate_range m n t</span>: Repeat the given tactic at least <span style="background-color:#fdf6e3;color:#657b83;">m</span> times and
at most <span style="background-color:#fdf6e3;color:#657b83;">n</span> times or until <span style="background-color:#fdf6e3;color:#657b83;">t</span> fails. Fails if <span style="background-color:#fdf6e3;color:#657b83;">t</span> does not run at least m times.</p>
</div></div><div class="decl"><h4>tactic.replace_at</h4><div class="decl_par"><p>Given a tactic <span style="background-color:#fdf6e3;color:#657b83;">tac</span> that takes an expression
and returns a new expression and a proof of equality,
use that tactic to change the type of the hypotheses listed in <span style="background-color:#fdf6e3;color:#657b83;">hs</span>,
as well as the goal if <span style="background-color:#fdf6e3;color:#657b83;">tgt </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> tt</span>.</p>
<p>Returns <span style="background-color:#fdf6e3;color:#657b83;">tt</span> if any types were successfully changed.</p>
</div></div><div class="decl"><h4>tactic.simp_bottom_up'</h4><div class="decl_par"><p>A variant of <span style="background-color:#fdf6e3;color:#657b83;">simplify_bottom_up</span>. Given a tactic <span style="background-color:#fdf6e3;color:#657b83;">post</span> for rewriting subexpressions,
<span style="background-color:#fdf6e3;color:#657b83;">simp_bottom_up post e</span> tries to rewrite <span style="background-color:#fdf6e3;color:#657b83;">e</span> starting at the leaf nodes. Returns the resulting
expression and a proof of equality.</p>
</div></div><div class="decl"><h4>tactic.instance_cache</h4><div class="decl_par"><p>Caches unary type classes on a type <span style="background-color:#fdf6e3;color:#657b83;">α : </span><span style="background-color:#fdf6e3;color:#268bd2;">Type</span><span style="background-color:#fdf6e3;color:#657b83;">.{univ}</span></p>
</div></div><div class="decl"><h4>tactic.mk_instance_cache</h4><div class="decl_par"><p>Creates an <span style="background-color:#fdf6e3;color:#657b83;">instance_cache</span> for the type <span style="background-color:#fdf6e3;color:#657b83;">α</span></p>
</div></div><div class="decl"><h4>tactic.instance_cache.get</h4><div class="decl_par"><p>If <span style="background-color:#fdf6e3;color:#657b83;">n</span> is the name of a type class with one parameter, <span style="background-color:#fdf6e3;color:#657b83;">get c n</span> tries to find an instance of
<span style="background-color:#fdf6e3;color:#657b83;">n c.α</span> by checking the cache <span style="background-color:#fdf6e3;color:#657b83;">c</span>. If there is no entry in the cache, it tries to find the instance
via type class resolution, and updates the cache.</p>
</div></div><div class="decl"><h4>tactic.instance_cache.append_typeclasses</h4><div class="decl_par"><p>If <span style="background-color:#fdf6e3;color:#657b83;">e</span> is a <span style="background-color:#fdf6e3;color:#657b83;">pi</span> expression that binds an instance-implicit variable of type <span style="background-color:#fdf6e3;color:#657b83;">n</span>,
<span style="background-color:#fdf6e3;color:#657b83;">append_typeclasses e c l</span> searches <span style="background-color:#fdf6e3;color:#657b83;">c</span> for an instance <span style="background-color:#fdf6e3;color:#657b83;">p</span> of type <span style="background-color:#fdf6e3;color:#657b83;">n</span> and returns <span style="background-color:#fdf6e3;color:#657b83;">p :: l</span>.</p>
</div></div><div class="decl"><h4>tactic.instance_cache.mk_app</h4><div class="decl_par"><p>Creates the application <span style="background-color:#fdf6e3;color:#657b83;">n c.α p l</span>, where <span style="background-color:#fdf6e3;color:#657b83;">p</span> is a type class instance found in the cache <span style="background-color:#fdf6e3;color:#657b83;">c</span>.</p>
</div></div><div class="decl"><h4>tactic.get_expl_pi_arity</h4><div class="decl_par"><p>Compute the arity of explicit arguments of the given (Pi-)type</p>
</div></div><div class="decl"><h4>tactic.get_expl_arity</h4><div class="decl_par"><p>Compute the arity of explicit arguments of the given function</p>
</div></div><div class="decl"><h4>tactic.get_pi_binders_aux</h4><div class="decl_par"><p>Auxilliary defintion for <span style="background-color:#fdf6e3;color:#657b83;">get_pi_binders</span>.</p>
</div></div><div class="decl"><h4>tactic.get_pi_binders</h4><div class="decl_par"><p>Get the binders and target of a pi-type. Instantiates bound variables by
local constants. Cf. <span style="background-color:#fdf6e3;color:#657b83;">pi_binders</span> in <span style="background-color:#fdf6e3;color:#859900;">meta</span><span style="background-color:#fdf6e3;color:#657b83;">.expr</span> (which produces open terms).
See also <span style="background-color:#fdf6e3;color:#657b83;">mk_local_pis</span> in <span style="background-color:#fdf6e3;color:#657b83;">init.core.tactic</span> which does almost the same.</p>
</div></div><div class="decl"><h4>tactic.local_proof</h4><div class="decl_par"><p>variation on <span style="background-color:#fdf6e3;color:#859900;">assert</span> where a (possibly incomplete)
proof of the assertion is provided as a parameter.</p>
<p><span style="background-color:#fdf6e3;color:#657b83;">(h,gs) ← local_proof `h p tac</span> creates a local <span style="background-color:#fdf6e3;color:#657b83;">h : p</span> and
use <span style="background-color:#fdf6e3;color:#657b83;">tac</span> to (partially) construct a proof for it. <span style="background-color:#fdf6e3;color:#657b83;">gs</span> is the
list of remaining goals in the proof of <span style="background-color:#fdf6e3;color:#657b83;">h</span>.</p>
<p>The benefits over assert are:</p>
<ul>
<li>unlike with <span style="background-color:#fdf6e3;color:#657b83;">h ← </span><span style="background-color:#fdf6e3;color:#859900;">assert</span><span style="background-color:#fdf6e3;color:#657b83;"> `h p, tac</span> , <span style="background-color:#fdf6e3;color:#657b83;">h</span> cannot be used by <span style="background-color:#fdf6e3;color:#657b83;">tac</span>;</li>
<li>when <span style="background-color:#fdf6e3;color:#657b83;">tac</span> does not complete the proof of <span style="background-color:#fdf6e3;color:#657b83;">h</span>, returning the list
of goals allows one to write a tactic using <span style="background-color:#fdf6e3;color:#657b83;">h</span> and with the confidence
that a proof will not boil over to goals left over from the proof of <span style="background-color:#fdf6e3;color:#657b83;">h</span>,
unlike what would be the case when using <span style="background-color:#fdf6e3;color:#657b83;">tactic.swap</span>.</li>
</ul>
</div></div><div class="decl"><h4>tactic.var_names</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">var_names e</span> returns a list of the unique names of the initial pi bindings in <span style="background-color:#fdf6e3;color:#657b83;">e</span>.</p>
</div></div><div class="decl"><h4>tactic.subobject_names</h4><div class="decl_par"><p>When <span style="background-color:#fdf6e3;color:#657b83;">struct_n</span> is the name of a structure type,
<span style="background-color:#fdf6e3;color:#657b83;">subobject_names struct_n</span> returns two lists of names <span style="background-color:#fdf6e3;color:#657b83;">(</span><span style="background-color:#fdf6e3;color:#859900;">instances</span><span style="background-color:#fdf6e3;color:#657b83;">, fields)</span>.
The names in <span style="background-color:#fdf6e3;color:#859900;">instances</span> are the projections from <span style="background-color:#fdf6e3;color:#657b83;">struct_n</span> to the structures that it extends
(assuming it was defined with <span style="background-color:#fdf6e3;color:#657b83;">old_structure_cmd false</span>).
The names in <span style="background-color:#fdf6e3;color:#657b83;">fields</span> are the standard fields of <span style="background-color:#fdf6e3;color:#657b83;">struct_n</span>.</p>
</div></div><div class="decl"><h4>tactic.expanded_field_list</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">expanded_field_list struct_n</span> produces a list of the names of the fields of the structure
named <span style="background-color:#fdf6e3;color:#657b83;">struct_n</span>. These are returned as pairs of names <span style="background-color:#fdf6e3;color:#657b83;">(</span><span style="background-color:#fdf6e3;color:#859900;">prefix</span><span style="background-color:#fdf6e3;color:#657b83;">, name)</span>, where the full name
of the projection is <span style="background-color:#fdf6e3;color:#859900;">prefix</span><span style="background-color:#fdf6e3;color:#657b83;">.name</span>.</p>
</div></div><div class="decl"><h4>tactic.get_classes</h4><div class="decl_par"><p>Return a list of all type classes which can be instantiated
for the given expression.</p>
</div></div><div class="decl"><h4>tactic.mk_mvar_list</h4><div class="decl_par"><p>Create a list of <span style="background-color:#fdf6e3;color:#657b83;">n</span> fresh metavariables.</p>
</div></div><div class="decl"><h4>tactic.get_goal</h4><div class="decl_par"><p>Returns the only goal, or fails if there isn't just one goal.</p>
</div></div><div class="decl"><h4>tactic.iterate_at_most_on_all_goals</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">iterate_at_most_on_all_goals n t</span>: repeat the given tactic at most <span style="background-color:#fdf6e3;color:#657b83;">n</span> times on all goals,
or until it fails. Always succeeds.</p>
</div></div><div class="decl"><h4>tactic.iterate_at_most_on_subgoals</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">iterate_at_most_on_subgoals n t</span>: repeat the tactic <span style="background-color:#fdf6e3;color:#657b83;">t</span> at most <span style="background-color:#fdf6e3;color:#657b83;">n</span> times on the first
goal and on all subgoals thus produced, or until it fails. Fails iff <span style="background-color:#fdf6e3;color:#657b83;">t</span> fails on
current goal.</p>
</div></div><div class="decl"><h4>tactic.apply_list_expr</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">apply_list l</span>: try to apply the tactics in the list <span style="background-color:#fdf6e3;color:#657b83;">l</span> on the first goal, and
fail if none succeeds</p>
</div></div><div class="decl"><h4>tactic.build_list_expr_for_apply</h4><div class="decl_par"><p>constructs a list of expressions given a list of p-expressions, as follows:</p>
<ul>
<li>if the p-expression is the name of a theorem, use <span style="background-color:#fdf6e3;color:#657b83;">i_to_expr_for_apply</span> on it</li>
<li>if the p-expression is a user attribute, add all the theorems with this attribute
to the list.</li>
</ul>
</div></div><div class="decl"><h4>tactic.apply_rules</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">apply_rules hs n</span>: apply the list of rules <span style="background-color:#fdf6e3;color:#657b83;">hs</span> (given as pexpr) and <span style="background-color:#fdf6e3;color:#657b83;">assumption</span> on the
first goal and the resulting subgoals, iteratively, at most <span style="background-color:#fdf6e3;color:#657b83;">n</span> times</p>
</div></div><div class="decl"><h4>tactic.replace</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">replace h p</span> elaborates the pexpr <span style="background-color:#fdf6e3;color:#657b83;">p</span>, clears the existing hypothesis named <span style="background-color:#fdf6e3;color:#657b83;">h</span> from the local
context, and adds a new hypothesis named <span style="background-color:#fdf6e3;color:#657b83;">h</span>. The type of this hypothesis is the type of <span style="background-color:#fdf6e3;color:#657b83;">p</span>.
Fails if there is nothing named <span style="background-color:#fdf6e3;color:#657b83;">h</span> in the local context.</p>
</div></div><div class="decl"><h4>tactic.mk_iff_mp_app</h4><div class="decl_par"><p>Auxiliary function for <span style="background-color:#fdf6e3;color:#657b83;">iff_mp</span> and <span style="background-color:#fdf6e3;color:#657b83;">iff_mpr</span>. Takes a name, which should be either <span style="background-color:#fdf6e3;color:#657b83;"> `iff.mp</span>
or <span style="background-color:#fdf6e3;color:#657b83;"> `iff.mpr</span>. If the passed expression is an iterated function type eventually producing an
<span style="background-color:#fdf6e3;color:#657b83;">iff</span>, returns an expression with the <span style="background-color:#fdf6e3;color:#657b83;">iff</span> converted to either the forwards or backwards
implication, as requested.</p>
</div></div><div class="decl"><h4>tactic.iff_mp_core</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">iff_mp_core e ty</span> assumes that <span style="background-color:#fdf6e3;color:#657b83;">ty</span> is the type of <span style="background-color:#fdf6e3;color:#657b83;">e</span>.
If <span style="background-color:#fdf6e3;color:#657b83;">ty</span> has the shape <span style="background-color:#fdf6e3;color:#657b83;">Π ..., A </span><span style="background-color:#fdf6e3;color:#b58900;">↔</span><span style="background-color:#fdf6e3;color:#657b83;"> B</span>, returns an expression whose type is <span style="background-color:#fdf6e3;color:#657b83;">Π ..., A </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> B</span></p>
</div></div><div class="decl"><h4>tactic.iff_mpr_core</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">iff_mpr_core e ty</span> assumes that <span style="background-color:#fdf6e3;color:#657b83;">ty</span> is the type of <span style="background-color:#fdf6e3;color:#657b83;">e</span>.
If <span style="background-color:#fdf6e3;color:#657b83;">ty</span> has the shape <span style="background-color:#fdf6e3;color:#657b83;">Π ..., A </span><span style="background-color:#fdf6e3;color:#b58900;">↔</span><span style="background-color:#fdf6e3;color:#657b83;"> B</span>, returns an expression whose type is <span style="background-color:#fdf6e3;color:#657b83;">Π ..., B </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> A</span></p>
</div></div><div class="decl"><h4>tactic.iff_mp</h4><div class="decl_par"><p>Given an expression whose type is (a possibly iterated function producing) an <span style="background-color:#fdf6e3;color:#657b83;">iff</span>,
create the expression which is the forward implication.</p>
</div></div><div class="decl"><h4>tactic.iff_mpr</h4><div class="decl_par"><p>Given an expression whose type is (a possibly iterated function producing) an <span style="background-color:#fdf6e3;color:#657b83;">iff</span>,
create the expression which is the reverse implication.</p>
</div></div><div class="decl"><h4>tactic.apply_iff</h4><div class="decl_par"><p>Attempts to apply <span style="background-color:#fdf6e3;color:#657b83;">e</span>, and if that fails, if <span style="background-color:#fdf6e3;color:#657b83;">e</span> is an <span style="background-color:#fdf6e3;color:#657b83;">iff</span>,
try applying both directions separately.</p>
</div></div><div class="decl"><h4>tactic.symm_apply</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">symm_apply e cfg</span> tries <span style="background-color:#fdf6e3;color:#657b83;">apply e cfg</span>, and if this fails, calls <span style="background-color:#fdf6e3;color:#657b83;">symmetry</span> and tries again.</p>
</div></div><div class="decl"><h4>tactic.apply_assumption</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">apply_assumption</span> searches for terms in the local context that can be applied to make progress
on the goal. If the goal is symmetric, it tries each goal in both directions. If this fails, it will
call <span style="background-color:#fdf6e3;color:#657b83;">exfalso</span> and repeat. Optional arguments:</p>
<ul>
<li><span style="background-color:#fdf6e3;color:#657b83;">asms</span> controls which expressions are applied. Defaults to <span style="background-color:#fdf6e3;color:#657b83;">local_context</span></li>
<li><span style="background-color:#fdf6e3;color:#657b83;">tac</span> is called after a successful application. Defaults to <span style="background-color:#fdf6e3;color:#657b83;">skip</span></li>
</ul>
</div></div><div class="decl"><h4>tactic.change_core</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">change_core e none</span> is equivalent to <span style="background-color:#fdf6e3;color:#657b83;">change e</span>. It tries to change the goal to <span style="background-color:#fdf6e3;color:#657b83;">e</span> and fails
if this is not a definitional equality.</p>
<p><span style="background-color:#fdf6e3;color:#657b83;">change_core e (some h)</span> assumes <span style="background-color:#fdf6e3;color:#657b83;">h</span> is a local constant, and tries to change the type of <span style="background-color:#fdf6e3;color:#657b83;">h</span> to <span style="background-color:#fdf6e3;color:#657b83;">e</span>
by reverting <span style="background-color:#fdf6e3;color:#657b83;">h</span>, changing the goal, and reintroducing hypotheses.</p>
</div></div><div class="decl"><h4>tactic.change_with_at</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">change_with_at olde newe hyp</span> replaces occurences of <span style="background-color:#fdf6e3;color:#657b83;">olde</span> with <span style="background-color:#fdf6e3;color:#657b83;">newe</span> at hypothesis <span style="background-color:#fdf6e3;color:#657b83;">hyp</span>,
assuming <span style="background-color:#fdf6e3;color:#657b83;">olde</span> and <span style="background-color:#fdf6e3;color:#657b83;">newe</span> are defeq when elaborated.</p>
</div></div><div class="decl"><h4>tactic.metavariables</h4><div class="decl_par"><p>Returns a list of all metavariables in the current partial proof. This can differ from
the list of goals, since the goals can be manually edited.</p>
</div></div><div class="decl"><h4>tactic.no_mvars_in_target</h4><div class="decl_par"><p>Fail if the target contains a metavariable.</p>
</div></div><div class="decl"><h4>tactic.propositional_goal</h4><div class="decl_par"><p>Succeeds only if the current goal is a proposition.</p>
</div></div><div class="decl"><h4>tactic.subsingleton_goal</h4><div class="decl_par"><p>Succeeds only if we can construct an instance showing the
current goal is a subsingleton type.</p>
</div></div><div class="decl"><h4>tactic.terminal_goal</h4><div class="decl_par"><p>Succeeds only if the current goal is &quot;terminal&quot;,
in the sense that no other goals depend on it
(except possibly through shared metavariables; see <span style="background-color:#fdf6e3;color:#657b83;">independent_goal</span>).</p>
</div></div><div class="decl"><h4>tactic.independent_goal</h4><div class="decl_par"><p>Succeeds only if the current goal is &quot;independent&quot;, in the sense
that no other goals depend on it, even through shared meta-variables.</p>
</div></div><div class="decl"><h4>tactic.triv'</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">triv&#39;</span> tries to close the first goal with the proof <span style="background-color:#fdf6e3;color:#657b83;">trivial : true</span>. Unlike <span style="background-color:#fdf6e3;color:#657b83;">triv</span>,
it only unfolds reducible definitions, so it sometimes fails faster.</p>
</div></div><div class="decl"><h4>tactic.iterate'</h4><div class="decl_par"><p>Apply a tactic as many times as possible, collecting the results in a list.</p>
</div></div><div class="decl"><h4>tactic.iterate1</h4><div class="decl_par"><p>Apply a tactic as many times as possible, collecting the results in a list.
Fail if the tactic does not succeed at least once.</p>
</div></div><div class="decl"><h4>tactic.intros1</h4><div class="decl_par"><p>Introduces one or more variables and returns the new local constants.
Fails if <span style="background-color:#fdf6e3;color:#657b83;">intro</span> cannot be applied.</p>
</div></div><div class="decl"><h4>tactic.successes</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">successes</span> invokes each tactic in turn, returning the list of successful results.</p>
</div></div><div class="decl"><h4>_private.3921497269.target'</h4><div class="decl_par"><p>Return target after instantiating metavars and whnf</p>
</div></div><div class="decl"><h4>tactic.fsplit</h4><div class="decl_par"><p>Just like <span style="background-color:#fdf6e3;color:#657b83;">split</span>, <span style="background-color:#fdf6e3;color:#657b83;">fsplit</span> applies the constructor when the type of the target is an inductive data type with one constructor.
However it does not reorder goals or invoke <span style="background-color:#fdf6e3;color:#657b83;">auto_param</span> tactics.</p>
</div></div><div class="decl"><h4>tactic.injections_and_clear</h4><div class="decl_par"><p>Calls <span style="background-color:#fdf6e3;color:#657b83;">injection</span> on each hypothesis, and then, for each hypothesis on which <span style="background-color:#fdf6e3;color:#657b83;">injection</span>
succeeds, clears the old hypothesis.</p>
</div></div><div class="decl"><h4>tactic.case_bash</h4><div class="decl_par"><p>calls <span style="background-color:#fdf6e3;color:#657b83;">cases</span> on every local hypothesis, succeeding if
it succeeds on at least one hypothesis.</p>
</div></div><div class="decl"><h4>tactic.note_anon</h4><div class="decl_par"><p>given a proof <span style="background-color:#fdf6e3;color:#657b83;">pr : t</span>, adds <span style="background-color:#fdf6e3;color:#657b83;">h : t</span> to the current context, where the name <span style="background-color:#fdf6e3;color:#657b83;">h</span> is fresh.</p>
</div></div><div class="decl"><h4>tactic.find_local</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">find_local t</span> returns a local constant with type t, or fails if none exists.</p>
</div></div><div class="decl"><h4>tactic.dependent_pose_core</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">dependent_pose_core l</span>: introduce dependent hypothesis, where the proofs depend on the values
of the previous local constants. <span style="background-color:#fdf6e3;color:#657b83;">l</span> is a list of local constants and their values.</p>
</div></div><div class="decl"><h4>tactic.mk_local_pis_whnf</h4><div class="decl_par"><p>like <span style="background-color:#fdf6e3;color:#657b83;">mk_local_pis</span> but translating into weak head normal form before checking if it is a Π.</p>
</div></div><div class="decl"><h4>tactic.choose1</h4><div class="decl_par"><p>Changes <span style="background-color:#fdf6e3;color:#657b83;">(h : </span><span style="background-color:#fdf6e3;color:#859900;">∀</span><span style="background-color:#fdf6e3;color:#657b83;">xs, ∃a:α, p a) ⊢ g</span> to <span style="background-color:#fdf6e3;color:#657b83;">(d : </span><span style="background-color:#fdf6e3;color:#859900;">∀</span><span style="background-color:#fdf6e3;color:#657b83;">xs, a) (s : </span><span style="background-color:#fdf6e3;color:#859900;">∀</span><span style="background-color:#fdf6e3;color:#657b83;">xs, p (d xs) ⊢ g</span></p>
</div></div><div class="decl"><h4>tactic.choose</h4><div class="decl_par"><p>Changes <span style="background-color:#fdf6e3;color:#657b83;">(h : </span><span style="background-color:#fdf6e3;color:#859900;">∀</span><span style="background-color:#fdf6e3;color:#657b83;">xs, ∃</span><span style="background-color:#fdf6e3;color:#859900;">as</span><span style="background-color:#fdf6e3;color:#657b83;">, p </span><span style="background-color:#fdf6e3;color:#859900;">as</span><span style="background-color:#fdf6e3;color:#657b83;">) ⊢ g</span> to a list of functions <span style="background-color:#fdf6e3;color:#859900;">as</span>, and a final hypothesis on <span style="background-color:#fdf6e3;color:#657b83;">p </span><span style="background-color:#fdf6e3;color:#859900;">as</span></p>
</div></div><div class="decl"><h4>tactic.instantiate_mvars_in_target</h4><div class="decl_par"><p>Instantiates metavariables that appear in the current goal.</p>
</div></div><div class="decl"><h4>tactic.instantiate_mvars_in_goals</h4><div class="decl_par"><p>Instantiates metavariables in all goals.</p>
</div></div><div class="decl"><h4>tactic.lock_tactic_state</h4><div class="decl_par"><p>This makes sure that the execution of the tactic does not change the tactic state.
This can be helpful while using rewrite, apply, or expr munging.
Remember to instantiate your metavariables before you're done!</p>
</div></div><div class="decl"><h4>tactic.mk_meta_pis</h4><div class="decl_par"><p>similar to <span style="background-color:#fdf6e3;color:#657b83;">mk_local_pis</span> but make meta variables instead of
local constants</p>
</div></div><div class="decl"><h4>tactic.instance_stub</h4><div class="decl_par"><p>Hole command used to fill in a structure's field when specifying an instance.</p>
<p>In the following:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">instance </span><span style="color:#d33682;">: </span><span style="color:#657b83;">monad id </span><span style="color:#b58900;">:=
</span><span style="color:#657b83;">{! !}
</span></pre>
</code></pre>
<p>invoking hole command <span style="background-color:#fdf6e3;color:#657b83;">Instance Stub</span> produces:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">instance </span><span style="color:#d33682;">: </span><span style="color:#657b83;">monad id </span><span style="color:#b58900;">:=
</span><span style="color:#657b83;">{ map </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _,
</span><span style="color:#657b83;">  map_const </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _,
</span><span style="color:#657b83;">  pure </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _,
</span><span style="color:#657b83;">  seq </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _,
</span><span style="color:#657b83;">  seq_left </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _,
</span><span style="color:#657b83;">  seq_right </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _,
</span><span style="color:#657b83;">  bind </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _ }
</span></pre>
</code></pre>
</div></div><div class="decl"><h4>tactic.resolve_name'</h4><div class="decl_par"><p>Like <span style="background-color:#fdf6e3;color:#657b83;">resolve_name</span> except when the list of goals is
empty. In that situation <span style="background-color:#fdf6e3;color:#657b83;">resolve_name</span> fails whereas
<span style="background-color:#fdf6e3;color:#657b83;">resolve_name&#39;</span> simply proceeds on a dummy goal</p>
</div></div><div class="decl"><h4>tactic.strip_prefix</h4><div class="decl_par"><p>Strips unnecessary prefixes from a name, e.g. if a namespace is open.</p>
</div></div><div class="decl"><h4>tactic.mk_patterns</h4><div class="decl_par"><p>Used to format return strings for the hole commands <span style="background-color:#fdf6e3;color:#657b83;">match_stub</span> and <span style="background-color:#fdf6e3;color:#657b83;">eqn_stub</span>.</p>
</div></div><div class="decl"><h4>tactic.match_stub</h4><div class="decl_par"><p>Hole command used to generate a <span style="background-color:#fdf6e3;color:#859900;">match</span> expression.</p>
<p>In the following:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">meta def </span><span style="color:#d33682;">foo </span><span style="color:#657b83;">(e : expr) : tactic unit </span><span style="color:#b58900;">:=
</span><span style="color:#657b83;">{! e !}
</span></pre>
</code></pre>
<p>invoking hole command <span style="background-color:#fdf6e3;color:#657b83;">Match Stub</span> produces:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">meta def </span><span style="color:#d33682;">foo </span><span style="color:#657b83;">(e : expr) : tactic unit </span><span style="color:#b58900;">:=
</span><span style="color:#859900;">match</span><span style="color:#657b83;"> e </span><span style="color:#859900;">with
</span><span style="color:#657b83;">| (expr.var a) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.sort a) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.const a a_1) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.mvar a a_1 a_2) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.local_const a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.app a a_1) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.lam a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.pi a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.elet a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.macro a a_1) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#859900;">end
</span></pre>
</code></pre>
</div></div><div class="decl"><h4>tactic.eqn_stub</h4><div class="decl_par"><p>Hole command used to generate a <span style="background-color:#fdf6e3;color:#859900;">match</span> expression.</p>
<p>In the following:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">meta def </span><span style="color:#d33682;">foo </span><span style="color:#657b83;">: {! expr </span><span style="color:#859900;">→</span><span style="color:#657b83;"> tactic unit !} </span><span style="color:#93a1a1;">-- `:=` is omitted
</span></pre>
</code></pre>
<p>invoking hole command <span style="background-color:#fdf6e3;color:#657b83;">Equations Stub</span> produces:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">meta def </span><span style="color:#d33682;">foo </span><span style="color:#657b83;">: expr </span><span style="color:#859900;">→</span><span style="color:#657b83;"> tactic unit
</span><span style="color:#657b83;">| (expr.var a) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.sort a) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.const a a_1) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.mvar a a_1 a_2) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.local_const a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.app a a_1) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.lam a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.pi a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.elet a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.macro a a_1) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span></pre>
</code></pre>
<p>A similar result can be obtained by invoking <span style="background-color:#fdf6e3;color:#657b83;">Equations Stub</span> on the following:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">meta def </span><span style="color:#d33682;">foo </span><span style="color:#657b83;">: expr </span><span style="color:#859900;">→</span><span style="color:#657b83;"> tactic unit </span><span style="color:#b58900;">:= </span><span style="color:#93a1a1;">-- do not forget to write `:=`!!
</span><span style="color:#657b83;">{! !}
</span></pre>
</code></pre>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">meta def </span><span style="color:#d33682;">foo </span><span style="color:#657b83;">: expr </span><span style="color:#859900;">→</span><span style="color:#657b83;"> tactic unit </span><span style="color:#b58900;">:= </span><span style="color:#93a1a1;">-- don&#39;t forget to erase `:=`!!
</span><span style="color:#657b83;">| (expr.var a) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.sort a) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.const a a_1) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.mvar a a_1 a_2) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.local_const a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.app a a_1) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.lam a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.pi a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.elet a a_1 a_2 a_3) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span><span style="color:#657b83;">| (expr.macro a a_1) </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> _
</span></pre>
</code></pre>
</div></div><div class="decl"><h4>tactic.list_constructors_hole</h4><div class="decl_par"><p>This command lists the constructors that can be used to satisfy the expected type.</p>
<p>When used in the following hole:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">def </span><span style="color:#d33682;">foo </span><span style="color:#657b83;">: ℤ ⊕ ℕ </span><span style="color:#b58900;">:=
</span><span style="color:#657b83;">{! !}
</span></pre>
</code></pre>
<p>the command will produce:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">def </span><span style="color:#d33682;">foo </span><span style="color:#657b83;">: ℤ ⊕ ℕ </span><span style="color:#b58900;">:=
</span><span style="color:#657b83;">{! sum.inl, sum.inr !}
</span></pre>
</code></pre>
<p>and will display:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#657b83;">sum.inl : ℤ </span><span style="color:#859900;">→</span><span style="color:#657b83;"> ℤ ⊕ ℕ
</span><span style="color:#657b83;">
</span><span style="color:#657b83;">sum.inr : ℕ </span><span style="color:#859900;">→</span><span style="color:#657b83;"> ℤ ⊕ ℕ
</span></pre>
</code></pre>
</div></div><div class="decl"><h4>tactic.classical</h4><div class="decl_par"><p>Makes the declaration <span style="background-color:#fdf6e3;color:#657b83;">classical.prop_decidable</span> available to type class inference.
This asserts that all propositions are decidable, but does not have computational content.</p>
</div></div><div class="decl"><h4>tactic.mk_comp</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">mk_comp v e</span> checks whether <span style="background-color:#fdf6e3;color:#657b83;">e</span> is a sequence of nested applications <span style="background-color:#fdf6e3;color:#657b83;">f (g (h v))</span>, and if so,
returns the expression <span style="background-color:#fdf6e3;color:#657b83;">f ∘ g ∘ h</span>.</p>
</div></div><div class="decl"><h4>tactic.mk_higher_order_type</h4><div class="decl_par"><p>From a lemma of the shape <span style="background-color:#fdf6e3;color:#657b83;">∀ x, f (g x) </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> h x</span>
derive an auxiliary lemma of the form <span style="background-color:#fdf6e3;color:#657b83;">f ∘ g </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> h</span>
for reasoning about higher-order functions.</p>
</div></div><div class="decl"><h4>tactic.higher_order_attr</h4><div class="decl_par"><p>A user attribute that applies to lemmas of the shape <span style="background-color:#fdf6e3;color:#657b83;">∀ x, f (g x) </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> h x</span>.
It derives an auxiliary lemma of the form <span style="background-color:#fdf6e3;color:#657b83;">f ∘ g </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> h</span> for reasoning about higher-order functions.</p>
</div></div><div class="decl"><h4>_private.2222182991.use_aux</h4><div class="decl_par"><p>Use <span style="background-color:#fdf6e3;color:#657b83;">refine</span> to partially discharge the goal,
or call <span style="background-color:#fdf6e3;color:#657b83;">fconstructor</span> and try again.</p>
</div></div><div class="decl"><h4>tactic.use</h4><div class="decl_par"><p>Similar to <span style="background-color:#fdf6e3;color:#657b83;">existsi</span>, <span style="background-color:#fdf6e3;color:#657b83;">use l</span> will use entries in <span style="background-color:#fdf6e3;color:#657b83;">l</span> to instantiate existential obligations
at the beginning of a target. Unlike <span style="background-color:#fdf6e3;color:#657b83;">existsi</span>, the pexprs in <span style="background-color:#fdf6e3;color:#657b83;">l</span> are elaborated with respect to
the expected type.</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">example</span><span style="color:#657b83;"> : ∃ x : ℤ, x </span><span style="color:#b58900;">=</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">:=
</span><span style="color:#859900;">by</span><span style="color:#657b83;"> tactic.use ``(</span><span style="color:#6c71c4;">42</span><span style="color:#657b83;">)
</span></pre>
</code></pre>
<p>See the doc string for <span style="background-color:#fdf6e3;color:#657b83;">tactic.interactive.use</span> for more information.</p>
</div></div><div class="decl"><h4>tactic.clear_aux_decl_aux</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">clear_aux_decl_aux l</span> clears all expressions in <span style="background-color:#fdf6e3;color:#657b83;">l</span> that represent aux decls from the
local context.</p>
</div></div><div class="decl"><h4>tactic.clear_aux_decl</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">clear_aux_decl</span> clears all expressions from the local context that represent aux decls.</p>
</div></div><div class="decl"><h4>tactic.apply_at_aux</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">apply_at_aux e et [] h ht</span> (with <span style="background-color:#fdf6e3;color:#657b83;">et</span> the type of <span style="background-color:#fdf6e3;color:#657b83;">e</span> and <span style="background-color:#fdf6e3;color:#657b83;">ht</span> the type of <span style="background-color:#fdf6e3;color:#657b83;">h</span>)
finds a list of expressions <span style="background-color:#fdf6e3;color:#657b83;">vs</span> and returns (e.mk_args (vs ++ [h]), vs)</p>
</div></div><div class="decl"><h4>tactic.apply_at</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">apply_at e h</span> applies implication <span style="background-color:#fdf6e3;color:#657b83;">e</span> on hypothesis <span style="background-color:#fdf6e3;color:#657b83;">h</span> and replaces <span style="background-color:#fdf6e3;color:#657b83;">h</span> with the result</p>
</div></div><div class="decl"><h4>tactic.symmetry_hyp</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">symmetry_hyp h</span> applies symmetry on hypothesis <span style="background-color:#fdf6e3;color:#657b83;">h</span></p>
</div></div><div class="decl"><h4>tactic.setup_tactic_parser_cmd</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">setup_tactic_parser_cmd</span> is a user command that opens the namespaces used in writing
interactive tactics, and declares the local postfix notation <span style="background-color:#fdf6e3;color:#657b83;">?</span> for <span style="background-color:#fdf6e3;color:#657b83;">optional</span> and <span style="background-color:#fdf6e3;color:#b58900;">*</span> for <span style="background-color:#fdf6e3;color:#657b83;">many</span>.
It does <em>not</em> use the <span style="background-color:#fdf6e3;color:#859900;">namespace</span> command, so it will typically be used after
<span style="background-color:#fdf6e3;color:#859900;">namespace</span><span style="background-color:#fdf6e3;color:#657b83;"> tactic.interactive</span>.</p>
</div></div><div class="decl"><h4>tactic.trace_error</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">trace_error msg t</span> executes the tactic <span style="background-color:#fdf6e3;color:#657b83;">t</span>. If <span style="background-color:#fdf6e3;color:#657b83;">t</span> fails, traces <span style="background-color:#fdf6e3;color:#657b83;">msg</span> and the failure message
of <span style="background-color:#fdf6e3;color:#657b83;">t</span>.</p>
</div></div><div class="decl"><h4>tactic.success_if_fail_with_msg</h4><div class="decl_par"><p>This combinator is for testing purposes. It succeeds if <span style="background-color:#fdf6e3;color:#657b83;">t</span> fails with message <span style="background-color:#fdf6e3;color:#657b83;">msg</span>,
and fails otherwise.</p>
</div></div><div class="decl"><h4>tactic.pformat</h4><div class="decl_par"><p>A type alias for <span style="background-color:#fdf6e3;color:#657b83;">tactic format</span>, standing for &quot;pretty print format&quot;.</p>
</div></div><div class="decl"><h4>tactic.pformat.mk</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">mk</span> lifts <span style="background-color:#fdf6e3;color:#657b83;">fmt : format</span> to the tactic monad (<span style="background-color:#fdf6e3;color:#657b83;">pformat</span>).</p>
</div></div><div class="decl"><h4>tactic.to_pfmt</h4><div class="decl_par"><p>an alias for <span style="background-color:#fdf6e3;color:#657b83;">pp</span>.</p>
</div></div><div class="decl"><h4>tactic.pformat_macro</h4><div class="decl_par"><p>See <span style="background-color:#fdf6e3;color:#657b83;">format!</span> in <span style="background-color:#fdf6e3;color:#657b83;">init</span><span style="background-color:#fdf6e3;color:#b58900;">/</span><span style="background-color:#fdf6e3;color:#859900;">meta</span><span style="background-color:#fdf6e3;color:#b58900;">/</span><span style="background-color:#fdf6e3;color:#657b83;">interactive_base.lean</span>.</p>
<p>The main differences are that <span style="background-color:#fdf6e3;color:#657b83;">pp</span> is called instead of <span style="background-color:#fdf6e3;color:#657b83;">to_fmt</span> and that we can use
arguments of type <span style="background-color:#fdf6e3;color:#657b83;">tactic α</span> in the quotations.</p>
<p>Now, consider the following:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#657b83;">e ← to_expr ``(</span><span style="color:#6c71c4;">3 </span><span style="color:#b58900;">+ </span><span style="color:#6c71c4;">7</span><span style="color:#657b83;">),
</span><span style="color:#657b83;">trace format!</span><span style="color:#2aa198;">&quot;{e}&quot;  </span><span style="color:#93a1a1;">-- outputs `has_add.add.{0} nat nat.has_add (bit1.{0} nat nat.has_one nat.has_add (has_one.one.{0} nat nat.has_one)) ...`
</span><span style="color:#657b83;">trace pformat!</span><span style="color:#2aa198;">&quot;{e}&quot; </span><span style="color:#93a1a1;">-- outputs `3 + 7`
</span></pre>
</code></pre>
<p>The difference is significant. And now, the following is expressible:</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#657b83;">e ← to_expr ``(</span><span style="color:#6c71c4;">3 </span><span style="color:#b58900;">+ </span><span style="color:#6c71c4;">7</span><span style="color:#657b83;">),
</span><span style="color:#657b83;">trace pformat!</span><span style="color:#2aa198;">&quot;{e} : {infer_type e}&quot; </span><span style="color:#93a1a1;">-- outputs `3 + 7 : ℕ`
</span></pre>
</code></pre>
<p>See also: <span style="background-color:#fdf6e3;color:#657b83;">trace!</span> and <span style="background-color:#fdf6e3;color:#657b83;">fail!</span></p>
</div></div><div class="decl"><h4>tactic.fail_macro</h4><div class="decl_par"><p>the combination of <span style="background-color:#fdf6e3;color:#657b83;">pformat</span> and <span style="background-color:#fdf6e3;color:#657b83;">fail</span></p>
</div></div><div class="decl"><h4>tactic.trace_macro</h4><div class="decl_par"><p>the combination of <span style="background-color:#fdf6e3;color:#657b83;">pformat</span> and <span style="background-color:#fdf6e3;color:#657b83;">fail</span></p>
</div></div><div class="decl"><h4>tactic.get_mathlib_dir</h4><div class="decl_par"><p>A hackish way to get the <span style="background-color:#fdf6e3;color:#657b83;">src</span> directory of mathlib.</p>
</div></div><div class="decl"><h4>tactic.is_in_mathlib</h4><div class="decl_par"><p>Checks whether a declaration with the given name is declared in mathlib.
If you want to run this tactic many times, you should use <span style="background-color:#fdf6e3;color:#657b83;">environment.is_prefix_of_file</span> instead,
since it is expensive to execute <span style="background-color:#fdf6e3;color:#657b83;">get_mathlib_dir</span> many times.</p>
</div></div><div class="decl"><h4>_private.996910851.apply_under_pis_aux</h4><div class="decl_par"><p>auxiliary function for apply_under_pis</p>
</div></div><div class="decl"><h4>tactic.apply_under_pis</h4><div class="decl_par"><p>Assumes <span style="background-color:#fdf6e3;color:#657b83;">pi_expr</span> is of the form <span style="background-color:#fdf6e3;color:#657b83;">Π x1 ... xn, _</span>.
Creates a pexpr of the form <span style="background-color:#fdf6e3;color:#657b83;">Π x1 ... xn, func (arg x1 ... xn)</span>.
All arguments (implicit and explicit) to <span style="background-color:#fdf6e3;color:#657b83;">arg</span> should be supplied.</p>
</div></div><div class="decl"><h4>tactic.delta_instance</h4><div class="decl_par"><p>Tries to derive instances by unfolding the newly introduced type and applying type class resolution.</p>
<p>For example,</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#586e75;">@[derive ring] </span><span style="color:#859900;">def </span><span style="color:#d33682;">new_int </span><span style="color:#657b83;">: </span><span style="color:#268bd2;">Type </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> ℤ
</span></pre>
</code></pre>
<p>adds an instance <span style="background-color:#fdf6e3;color:#657b83;">ring new_int</span>, defined to be the instance of <span style="background-color:#fdf6e3;color:#657b83;">ring ℤ</span> found by <span style="background-color:#fdf6e3;color:#657b83;">apply_instance</span>.</p>
<p>Multiple instances can be added with <span style="background-color:#fdf6e3;color:#586e75;">@[derive [ring, module ℝ]</span><span style="background-color:#fdf6e3;color:#657b83;">]</span>.</p>
<p>This derive handler applies only to declarations made using <span style="background-color:#fdf6e3;color:#859900;">def</span>, and will fail on such a
declaration if it is unable to derive an instance. It is run with higher priority than the built-in
handlers, which will fail on <span style="background-color:#fdf6e3;color:#859900;">def</span>s.</p>
</div></div><div class="decl"><h4>tactic.find_private_decl</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">find_private_decl n none</span> finds a private declaration named <span style="background-color:#fdf6e3;color:#657b83;">n</span> in any of the imported files.</p>
<p><span style="background-color:#fdf6e3;color:#657b83;">find_private_decl n (some m)</span> finds a private declaration named <span style="background-color:#fdf6e3;color:#657b83;">n</span> in the same file where a declaration named <span style="background-color:#fdf6e3;color:#657b83;">m</span>
can be found.</p>
</div></div><div class="decl"><h4>tactic.import_private_cmd</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">import_private foo </span><span style="background-color:#fdf6e3;color:#859900;">from</span><span style="background-color:#fdf6e3;color:#657b83;"> bar</span> finds a private declaration <span style="background-color:#fdf6e3;color:#657b83;">foo</span> in the same file as <span style="background-color:#fdf6e3;color:#657b83;">bar</span>
and creates a local notation to refer to it.</p>
<p><span style="background-color:#fdf6e3;color:#657b83;">import_private foo</span>, looks for <span style="background-color:#fdf6e3;color:#657b83;">foo</span> in all imported files.</p>
</div></div></html>