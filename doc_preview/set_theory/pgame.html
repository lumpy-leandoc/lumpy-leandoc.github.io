<html><head><link rel="stylesheet" href="../docs_style.css"></head><h1>Combinatorial (pre-)games.</h1>
<p>The basic theory of combinatorial games, following Conway's book <span style="background-color:#fdf6e3;color:#657b83;">On Numbers and Games</span>. We
construct &quot;pregames&quot;, define an ordering and arithmetic operations on them, then show that the
operations descend to &quot;games&quot;, defined via the equivalence relation <span style="background-color:#fdf6e3;color:#657b83;">p ≈ q </span><span style="background-color:#fdf6e3;color:#b58900;">↔</span><span style="background-color:#fdf6e3;color:#657b83;"> p </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> q </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> q </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> p</span>.</p>
<p>The surreal numbers will be built as a quotient of a subtype of pregames.</p>
<p>A pregame (<span style="background-color:#fdf6e3;color:#657b83;">pgame</span> below) is axiomatised via an inductive type, whose sole constructor takes two
types (thought of as indexing the the possible moves for the players Left and Right), and a pair of
functions out of these types to <span style="background-color:#fdf6e3;color:#657b83;">pgame</span> (thought of as describing the resulting game after making a
move).</p>
<p>Combinatorial games themselves, as a quotient of pregames, are constructed in <span style="background-color:#fdf6e3;color:#657b83;">game.lean</span>.</p>
<h2>Conway induction</h2>
<p>By construction, the induction principle for pregames is exactly &quot;Conway induction&quot;. That is, to
prove some predicate <span style="background-color:#fdf6e3;color:#657b83;">pgame </span><span style="background-color:#fdf6e3;color:#859900;">→ </span><span style="background-color:#fdf6e3;color:#268bd2;">Prop</span> holds for all pregames, it suffices to prove that for every
pregame <span style="background-color:#fdf6e3;color:#657b83;">g</span>, if the predicate holds for every game resulting from making a move, then it also holds
for <span style="background-color:#fdf6e3;color:#657b83;">g</span>.</p>
<p>While it is often convenient to work &quot;by induction&quot; on pregames, in some situations this becomes
awkward, so we also define accessor functions <span style="background-color:#fdf6e3;color:#657b83;">left_moves</span>, <span style="background-color:#fdf6e3;color:#657b83;">right_moves</span>, <span style="background-color:#fdf6e3;color:#657b83;">move_left</span> and
<span style="background-color:#fdf6e3;color:#657b83;">move_right</span>. There is a relation <span style="background-color:#fdf6e3;color:#657b83;">subsequent p q</span>, saying that <span style="background-color:#fdf6e3;color:#657b83;">p</span> can be reached by playing some
non-empty sequence of moves starting from <span style="background-color:#fdf6e3;color:#657b83;">q</span>, an instance <span style="background-color:#fdf6e3;color:#657b83;">well_founded subsequent</span>, and a local
tactic <span style="background-color:#fdf6e3;color:#657b83;">pgame_wf_tac</span> which is helpful for discharging proof obligations in inductive proofs relying
on this relation.</p>
<h2>Order properties</h2>
<p>Pregames have both a <span style="background-color:#fdf6e3;color:#b58900;">≤</span> and a <span style="background-color:#fdf6e3;color:#b58900;">&lt;</span> relation, which are related in quite a subtle way. In particular,
it is worth noting that in Lean's (perhaps unfortunate?) definition of a <span style="background-color:#fdf6e3;color:#657b83;">preorder</span>, we have
<span style="background-color:#fdf6e3;color:#657b83;">lt_iff_le_not_le : </span><span style="background-color:#fdf6e3;color:#859900;">∀</span><span style="background-color:#fdf6e3;color:#657b83;"> a b : α, a </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> b </span><span style="background-color:#fdf6e3;color:#b58900;">↔</span><span style="background-color:#fdf6e3;color:#657b83;"> (a </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> b </span><span style="background-color:#fdf6e3;color:#b58900;">∧ ¬</span><span style="background-color:#fdf6e3;color:#657b83;"> b </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> a)</span>, but this is <em>not</em> satisfied by the usual
<span style="background-color:#fdf6e3;color:#b58900;">≤</span> and <span style="background-color:#fdf6e3;color:#b58900;">&lt;</span> relations on pregames. (It is satisfied once we restrict to the surreal numbers.) In
particular, <span style="background-color:#fdf6e3;color:#b58900;">&lt;</span> is not transitive; there is an example below showing <span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> star </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> star </span><span style="background-color:#fdf6e3;color:#b58900;">&lt; </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span>.</p>
<p>We do have</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">theorem </span><span style="color:#d33682;">not_le </span><span style="color:#657b83;">{x y : pgame} : </span><span style="color:#b58900;">¬</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">≤</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">↔</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">&lt;</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> ...
</span><span style="color:#859900;">theorem </span><span style="color:#d33682;">not_lt </span><span style="color:#657b83;">{x y : pgame} : </span><span style="color:#b58900;">¬</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">&lt;</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">↔</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">≤</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> ...
</span></pre>
</code></pre>
<p>The statement <span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> x</span> means that Left has a good response to any move by Right; in particular, the
theorem <span style="background-color:#fdf6e3;color:#657b83;">zero_le</span> below states</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#6c71c4;">0 </span><span style="color:#b58900;">≤</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">↔ </span><span style="color:#859900;">∀</span><span style="color:#657b83;"> j : x.right_moves, ∃ i : (x.move_right j).left_moves, </span><span style="color:#6c71c4;">0 </span><span style="color:#b58900;">≤</span><span style="color:#657b83;"> (x.move_right j).move_left i
</span></pre>
</code></pre>
<p>On the other hand the statement <span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> x</span> means that Left has a good move right now; in particular the
theorem <span style="background-color:#fdf6e3;color:#657b83;">zero_lt</span> below states</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#6c71c4;">0 </span><span style="color:#b58900;">&lt;</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">↔</span><span style="color:#657b83;"> ∃ i : left_moves x, </span><span style="color:#859900;">∀</span><span style="color:#657b83;"> j : right_moves (x.move_left i), </span><span style="color:#6c71c4;">0 </span><span style="color:#b58900;">&lt;</span><span style="color:#657b83;"> (x.move_left i).move_right j
</span></pre>
</code></pre>
<p>The theorems <span style="background-color:#fdf6e3;color:#657b83;">le_def</span>, <span style="background-color:#fdf6e3;color:#657b83;">lt_def</span>, give a recursive characterisation of each relation, in terms of
themselves two moves later. The theorems <span style="background-color:#fdf6e3;color:#657b83;">le_def_lt</span> and <span style="background-color:#fdf6e3;color:#657b83;">lt_def_lt</span> give recursive
characterisations of each relation in terms of the other relation one move later.</p>
<p>We define an equivalence relation <span style="background-color:#fdf6e3;color:#657b83;">equiv p q </span><span style="background-color:#fdf6e3;color:#b58900;">↔</span><span style="background-color:#fdf6e3;color:#657b83;"> p </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> q </span><span style="background-color:#fdf6e3;color:#b58900;">∧</span><span style="background-color:#fdf6e3;color:#657b83;"> q </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> p</span>. Later, games will be defined as the
quotient by this relation.</p>
<h2>Algebraic structures</h2>
<p>We next turn to defining the operations necessary to make games into a commutative additive group.
Addition is defined for $x = {xL | xR}$ and $y = {yL | yR}$ by $x + y = {xL + y, x + yL | xR +
y, x + yR}$. Negation is defined by ${xL | xR} = {-xR | -xL}$.</p>
<p>The order structures interact in the expected way with addition, so we have</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#859900;">theorem </span><span style="color:#d33682;">le_iff_sub_nonneg </span><span style="color:#657b83;">{x y : pgame} : x </span><span style="color:#b58900;">≤</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">↔ </span><span style="color:#6c71c4;">0 </span><span style="color:#b58900;">≤</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">-</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> sorry
</span><span style="color:#859900;">theorem </span><span style="color:#d33682;">lt_iff_sub_pos </span><span style="color:#657b83;">{x y : pgame} : x </span><span style="color:#b58900;">&lt;</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">↔ </span><span style="color:#6c71c4;">0 </span><span style="color:#b58900;">&lt;</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">-</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> sorry
</span></pre>
</code></pre>
<p>We show that these operations respect the equivalence relation, and hence descend to games. At the
level of games, these operations satisfy all the laws of a commutative group. To prove the necessary
equivalence relations at the level of pregames, we introduce the notion of a <span style="background-color:#fdf6e3;color:#657b83;">relabelling</span> of a
game, and show, for example, that there is a relabelling between <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> (y </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> z)</span> and <span style="background-color:#fdf6e3;color:#657b83;">(x </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> y) </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> z</span>.</p>
<h2>Future work</h2>
<ul>
<li>The theory of dominated and reversible positions, and unique normal form for short games.</li>
<li>Analysis of basic domineering positions.</li>
<li>Impartial games, nim, and the Sprague-Grundy theorem.</li>
<li>Hex.</li>
<li>Temperature.</li>
<li>The development of surreal numbers, based on this development of combinatorial games, is still
quite incomplete.</li>
</ul>
<h2>References</h2>
<p>The material here is all drawn from</p>
<ul>
<li>[Conway, <em>On numbers and games</em>][conway2001]</li>
</ul>
<p>An interested reader may like to formalise some of the material from</p>
<ul>
<li>[Andreas Blass, <em>A game semantics for linear logic</em>][MR1167694]</li>
<li>[André Joyal, <em>Remarques sur la théorie des jeux à deux personnes</em>][joyal1997]</li>
</ul>
<hr/><div class="decl"><h4>pgame</h4><div class="decl_par"><p>The type of pre-games, before we have quotiented
by extensionality. In ZFC, a combinatorial game is constructed from
two sets of combinatorial games that have been constructed at an earlier
stage. To do this in type theory, we say that a pre-game is built
inductively from two families of pre-games indexed over any type
in Type u. The resulting type <span style="background-color:#fdf6e3;color:#657b83;">pgame.{u}</span> lives in <span style="background-color:#fdf6e3;color:#268bd2;">Type</span><span style="background-color:#fdf6e3;color:#657b83;"> (u</span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#6c71c4;">1</span><span style="background-color:#fdf6e3;color:#657b83;">)</span>,
reflecting that it is a proper class in ZFC.</p>
</div></div><div class="decl"><h4>pgame.of_lists</h4><div class="decl_par"><p>Construct a pre-game from list of pre-games describing the available moves for Left and Right.</p>
</div></div><div class="decl"><h4>pgame.left_moves</h4><div class="decl_par"><p>The indexing type for allowable moves by Left.</p>
</div></div><div class="decl"><h4>pgame.right_moves</h4><div class="decl_par"><p>The indexing type for allowable moves by Right.</p>
</div></div><div class="decl"><h4>pgame.move_left</h4><div class="decl_par"><p>The new game after Left makes an allowed move.</p>
</div></div><div class="decl"><h4>pgame.move_right</h4><div class="decl_par"><p>The new game after Right makes an allowed move.</p>
</div></div><div class="decl"><h4>pgame.subsequent</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">subsequent p q</span> says that <span style="background-color:#fdf6e3;color:#657b83;">p</span> can be obtained by playing
some nonempty sequence of moves from <span style="background-color:#fdf6e3;color:#657b83;">q</span>.</p>
</div></div><div class="decl"><h4>pgame.subsequent.left_move</h4><div class="decl_par"><p>A move by Left produces a subsequent game. (For use in pgame_wf_tac.)</p>
</div></div><div class="decl"><h4>pgame.subsequent.right_move</h4><div class="decl_par"><p>A move by Right produces a subsequent game. (For use in pgame_wf_tac.)</p>
</div></div><div class="decl"><h4>pgame.pgame_wf_tac</h4><div class="decl_par"><p>A local tactic for proving well-foundedness of recursive definitions involving pregames.</p>
</div></div><div class="decl"><h4>pgame.has_zero</h4><div class="decl_par"><p>The pre-game <span style="background-color:#fdf6e3;color:#657b83;">zero</span> is defined by <span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> { | }</span>.</p>
</div></div><div class="decl"><h4>pgame.has_one</h4><div class="decl_par"><p>The pre-game <span style="background-color:#fdf6e3;color:#657b83;">one</span> is defined by <span style="background-color:#fdf6e3;color:#6c71c4;">1 </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> { </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span><span style="background-color:#fdf6e3;color:#657b83;"> | }</span>.</p>
</div></div><div class="decl"><h4>pgame.le_lt</h4><div class="decl_par"><p>Define simultaneously by mutual induction the <span style="background-color:#fdf6e3;color:#b58900;">&lt;=</span> and <span style="background-color:#fdf6e3;color:#b58900;">&lt;</span>
relation on pre-games. The ZFC definition says that <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> {xL | xR}</span>
is less or equal to <span style="background-color:#fdf6e3;color:#657b83;">y </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> {yL | yR}</span> if <span style="background-color:#fdf6e3;color:#657b83;">∀ x₁ ∈ xL, x₁ </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span>
and <span style="background-color:#fdf6e3;color:#657b83;">∀ y₂ ∈ yR, x </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> y₂</span>, where <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> is the same as <span style="background-color:#fdf6e3;color:#b58900;">¬</span><span style="background-color:#fdf6e3;color:#657b83;"> y </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;=</span><span style="background-color:#fdf6e3;color:#657b83;"> x</span>.
This is a tricky induction because it only decreases one side at
a time, and it also swaps the arguments in the definition of <span style="background-color:#fdf6e3;color:#b58900;">&lt;</span>.
The solution is to define <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> and <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;=</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> simultaneously.</p>
</div></div><div class="decl"><h4>pgame.mk_le_mk</h4><div class="decl_par"><p>Definition of <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> on pre-games built using the constructor.</p>
</div></div><div class="decl"><h4>pgame.le_def_lt</h4><div class="decl_par"><p>Definition of <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> on pre-games, in terms of <span style="background-color:#fdf6e3;color:#b58900;">&lt;</span></p>
</div></div><div class="decl"><h4>pgame.mk_lt_mk</h4><div class="decl_par"><p>Definition of <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> on pre-games built using the constructor.</p>
</div></div><div class="decl"><h4>pgame.lt_def_le</h4><div class="decl_par"><p>Definition of <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> on pre-games, in terms of <span style="background-color:#fdf6e3;color:#b58900;">≤</span></p>
</div></div><div class="decl"><h4>pgame.le_def</h4><div class="decl_par"><p>The definition of <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> on pre-games, in terms of <span style="background-color:#fdf6e3;color:#b58900;">≤</span> two moves later.</p>
</div></div><div class="decl"><h4>pgame.lt_def</h4><div class="decl_par"><p>The definition of <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> on pre-games, in terms of <span style="background-color:#fdf6e3;color:#b58900;">&lt;</span> two moves later.</p>
</div></div><div class="decl"><h4>pgame.le_zero</h4><div class="decl_par"><p>The definition of <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">≤ </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span> on pre-games, in terms of <span style="background-color:#fdf6e3;color:#b58900;">≤ </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span> two moves later.</p>
</div></div><div class="decl"><h4>pgame.zero_le</h4><div class="decl_par"><p>The definition of <span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> x</span> on pre-games, in terms of <span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span> two moves later.</p>
</div></div><div class="decl"><h4>pgame.lt_zero</h4><div class="decl_par"><p>The definition of <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">&lt; </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span> on pre-games, in terms of <span style="background-color:#fdf6e3;color:#b58900;">&lt; </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span> two moves later.</p>
</div></div><div class="decl"><h4>pgame.zero_lt</h4><div class="decl_par"><p>The definition of <span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> x</span> on pre-games, in terms of <span style="background-color:#fdf6e3;color:#b58900;">&lt;</span><span style="background-color:#fdf6e3;color:#657b83;"> x</span> two moves later.</p>
</div></div><div class="decl"><h4>pgame.right_response</h4><div class="decl_par"><p>Given a right-player-wins game, provide a response to any move by left.</p>
</div></div><div class="decl"><h4>pgame.right_response_spec</h4><div class="decl_par"><p>Show that the response for right provided by <span style="background-color:#fdf6e3;color:#657b83;">right_response</span>
preserves the right-player-wins condition.</p>
</div></div><div class="decl"><h4>pgame.left_response</h4><div class="decl_par"><p>Given a left-player-wins game, provide a response to any move by right.</p>
</div></div><div class="decl"><h4>pgame.left_response_spec</h4><div class="decl_par"><p>Show that the response for left provided by <span style="background-color:#fdf6e3;color:#657b83;">left_response</span>
preserves the left-player-wins condition.</p>
</div></div><div class="decl"><h4>pgame.equiv</h4><div class="decl_par"><p>Define the equivalence relation on pre-games. Two pre-games
<span style="background-color:#fdf6e3;color:#657b83;">x</span>, <span style="background-color:#fdf6e3;color:#657b83;">y</span> are equivalent if <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> and <span style="background-color:#fdf6e3;color:#657b83;">y </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> x</span>.</p>
</div></div><div class="decl"><h4>pgame.restricted</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">restricted x y</span> says that Left always has no more moves in <span style="background-color:#fdf6e3;color:#657b83;">x</span> than in <span style="background-color:#fdf6e3;color:#657b83;">y</span>,
and Right always has no more moves in <span style="background-color:#fdf6e3;color:#657b83;">y</span> than in <span style="background-color:#fdf6e3;color:#657b83;">x</span></p>
</div></div><div class="decl"><h4>pgame.restricted.refl</h4><div class="decl_par"><p>The identity restriction.</p>
</div></div><div class="decl"><h4>pgame.relabelling</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">relabelling x y</span> says that <span style="background-color:#fdf6e3;color:#657b83;">x</span> and <span style="background-color:#fdf6e3;color:#657b83;">y</span> are really the same game, just dressed up differently.
Specifically, there is a bijection between the moves for Left in <span style="background-color:#fdf6e3;color:#657b83;">x</span> and in <span style="background-color:#fdf6e3;color:#657b83;">y</span>, and similarly
for Right, and under these bijections we inductively have <span style="background-color:#fdf6e3;color:#657b83;">relabelling</span>s for the consequent games.</p>
</div></div><div class="decl"><h4>pgame.restricted_of_relabelling</h4><div class="decl_par"><p>If <span style="background-color:#fdf6e3;color:#657b83;">x</span> is a relabelling of <span style="background-color:#fdf6e3;color:#657b83;">y</span>, then Left and Right have the same moves in either game,
so <span style="background-color:#fdf6e3;color:#657b83;">x</span> is a restriction of <span style="background-color:#fdf6e3;color:#657b83;">y</span>.</p>
</div></div><div class="decl"><h4>pgame.relabelling.refl</h4><div class="decl_par"><p>The identity relabelling.</p>
</div></div><div class="decl"><h4>pgame.relabelling.symm</h4><div class="decl_par"><p>Reverse a relabelling.</p>
</div></div><div class="decl"><h4>pgame.equiv_of_relabelling</h4><div class="decl_par"><p>A relabelling lets us prove equivalence of games.</p>
</div></div><div class="decl"><h4>pgame.relabel</h4><div class="decl_par"><p>Replace the types indexing the next moves for Left and Right by equivalent types.</p>
</div></div><div class="decl"><h4>pgame.relabel_relabelling</h4><div class="decl_par"><p>The game obtained by relabelling the next moves is a relabelling of the original game.</p>
</div></div><div class="decl"><h4>pgame.neg</h4><div class="decl_par"><p>The negation of <span style="background-color:#fdf6e3;color:#657b83;">{L | R}</span> is <span style="background-color:#fdf6e3;color:#657b83;">{</span><span style="background-color:#fdf6e3;color:#b58900;">-</span><span style="background-color:#fdf6e3;color:#657b83;">R | </span><span style="background-color:#fdf6e3;color:#b58900;">-</span><span style="background-color:#fdf6e3;color:#657b83;">L}</span>.</p>
</div></div><div class="decl"><h4>pgame.left_moves_neg</h4><div class="decl_par"><p>An explicit equivalence between the moves for Left in <span style="background-color:#fdf6e3;color:#b58900;">-</span><span style="background-color:#fdf6e3;color:#657b83;">x</span> and the moves for Right in <span style="background-color:#fdf6e3;color:#657b83;">x</span>.</p>
</div></div><div class="decl"><h4>pgame.right_moves_neg</h4><div class="decl_par"><p>An explicit equivalence between the moves for Right in <span style="background-color:#fdf6e3;color:#b58900;">-</span><span style="background-color:#fdf6e3;color:#657b83;">x</span> and the moves for Left in <span style="background-color:#fdf6e3;color:#657b83;">x</span>.</p>
</div></div><div class="decl"><h4>pgame.add</h4><div class="decl_par"><p>The sum of <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> {xL | xR}</span> and <span style="background-color:#fdf6e3;color:#657b83;">y </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> {yL | yR}</span> is <span style="background-color:#fdf6e3;color:#657b83;">{xL </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> y, x </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> yL | xR </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> y, x </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> yR}</span>.</p>
</div></div><div class="decl"><h4>pgame.add_zero_relabelling</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">+ </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span> has exactly the same moves as <span style="background-color:#fdf6e3;color:#657b83;">x</span>.</p>
</div></div><div class="decl"><h4>pgame.add_zero_equiv</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">+ </span><span style="background-color:#fdf6e3;color:#6c71c4;">0</span> is equivalent to <span style="background-color:#fdf6e3;color:#657b83;">x</span>.</p>
</div></div><div class="decl"><h4>pgame.zero_add_relabelling</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> x</span> has exactly the same moves as <span style="background-color:#fdf6e3;color:#657b83;">x</span>.</p>
</div></div><div class="decl"><h4>pgame.zero_add_equiv</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#6c71c4;">0 </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> x</span> is equivalent to <span style="background-color:#fdf6e3;color:#657b83;">x</span>.</p>
</div></div><div class="decl"><h4>pgame.left_moves_add</h4><div class="decl_par"><p>An explicit equivalence between the moves for Left in <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> and the type-theory sum
of the moves for Left in <span style="background-color:#fdf6e3;color:#657b83;">x</span> and in <span style="background-color:#fdf6e3;color:#657b83;">y</span>.</p>
</div></div><div class="decl"><h4>pgame.right_moves_add</h4><div class="decl_par"><p>An explicit equivalence between the moves for Right in <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> and the type-theory sum
of the moves for Right in <span style="background-color:#fdf6e3;color:#657b83;">x</span> and in <span style="background-color:#fdf6e3;color:#657b83;">y</span>.</p>
</div></div><div class="decl"><h4>pgame.neg_add_relabelling</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#b58900;">-</span><span style="background-color:#fdf6e3;color:#657b83;">(x</span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;">y)</span> has exactly the same moves as <span style="background-color:#fdf6e3;color:#b58900;">-</span><span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">+ -</span><span style="background-color:#fdf6e3;color:#657b83;">y</span>.</p>
</div></div><div class="decl"><h4>pgame.add_comm_relabelling</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">x</span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;">y</span> has exactly the same moves as <span style="background-color:#fdf6e3;color:#657b83;">y</span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;">x</span>.</p>
</div></div><div class="decl"><h4>pgame.add_assoc_relabelling</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">(x </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> y) </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> z</span> has exactly the same moves as <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> (y </span><span style="background-color:#fdf6e3;color:#b58900;">+</span><span style="background-color:#fdf6e3;color:#657b83;"> z)</span>.</p>
</div></div><div class="decl"><h4>pgame.star</h4><div class="decl_par"><p>The pre-game <span style="background-color:#fdf6e3;color:#657b83;">star</span>, which is fuzzy/confused with zero.</p>
</div></div><div class="decl"><h4>pgame.omega</h4><div class="decl_par"><p>The pre-game <span style="background-color:#fdf6e3;color:#657b83;">ω</span>. (In fact all ordinals have game and surreal representatives.)</p>
</div></div></html>