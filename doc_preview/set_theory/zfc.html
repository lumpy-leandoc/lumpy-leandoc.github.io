<html><head><link rel="stylesheet" href="../docs_style.css"></head><div class="decl"><h4>arity</h4><div class="decl_par"><p>The type of <span style="background-color:#fdf6e3;color:#657b83;">n</span>-ary functions <span style="background-color:#fdf6e3;color:#657b83;">α </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> α </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> ... </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> α</span>.</p>
</div></div><div class="decl"><h4>pSet</h4><div class="decl_par"><p>The type of pre-sets in universe <span style="background-color:#fdf6e3;color:#657b83;">u</span>. A pre-set
is a family of pre-sets indexed by a type in <span style="background-color:#fdf6e3;color:#268bd2;">Type</span><span style="background-color:#fdf6e3;color:#657b83;"> u</span>.
The ZFC universe is defined as a quotient of this
to ensure extensionality.</p>
</div></div><div class="decl"><h4>pSet.type</h4><div class="decl_par"><p>The underlying type of a pre-set</p>
</div></div><div class="decl"><h4>pSet.func</h4><div class="decl_par"><p>The underlying pre-set family of a pre-set</p>
</div></div><div class="decl"><h4>pSet.equiv</h4><div class="decl_par"><p>Two pre-sets are extensionally equivalent if every
element of the first family is extensionally equivalent to
some element of the second family and vice-versa.</p>
</div></div><div class="decl"><h4>pSet.mem</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">x ∈ y</span> as pre-sets if <span style="background-color:#fdf6e3;color:#657b83;">x</span> is extensionally equivalent to a member
of the family <span style="background-color:#fdf6e3;color:#657b83;">y</span>.</p>
</div></div><div class="decl"><h4>pSet.to_set</h4><div class="decl_par"><p>Convert a pre-set to a <span style="background-color:#fdf6e3;color:#657b83;">set</span> of pre-sets.</p>
</div></div><div class="decl"><h4>pSet.equiv.eq</h4><div class="decl_par"><p>Two pre-sets are equivalent iff they have the same members.</p>
</div></div><div class="decl"><h4>pSet.empty</h4><div class="decl_par"><p>The empty pre-set</p>
</div></div><div class="decl"><h4>pSet.insert</h4><div class="decl_par"><p>Insert an element into a pre-set</p>
</div></div><div class="decl"><h4>pSet.of_nat</h4><div class="decl_par"><p>The n-th von Neumann ordinal</p>
</div></div><div class="decl"><h4>pSet.omega</h4><div class="decl_par"><p>The von Neumann ordinal ω</p>
</div></div><div class="decl"><h4>pSet.sep</h4><div class="decl_par"><p>The separation operation <span style="background-color:#fdf6e3;color:#657b83;">{x ∈ a | p x}</span></p>
</div></div><div class="decl"><h4>pSet.powerset</h4><div class="decl_par"><p>The powerset operator</p>
</div></div><div class="decl"><h4>pSet.Union</h4><div class="decl_par"><p>The set union operator</p>
</div></div><div class="decl"><h4>pSet.image</h4><div class="decl_par"><p>The image of a function</p>
</div></div><div class="decl"><h4>pSet.lift</h4><div class="decl_par"><p>Universe lift operation</p>
</div></div><div class="decl"><h4>pSet.embed</h4><div class="decl_par"><p>Embedding of one universe in another</p>
</div></div><div class="decl"><h4>pSet.arity.equiv</h4><div class="decl_par"><p>Function equivalence is defined so that <span style="background-color:#fdf6e3;color:#657b83;">f ~ g</span> iff
<span style="background-color:#fdf6e3;color:#657b83;">∀ x y, x ~ y </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> f x ~ g y</span>. This extends to equivalence of n-ary
functions.</p>
</div></div><div class="decl"><h4>pSet.resp</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">resp n</span> is the collection of n-ary functions on <span style="background-color:#fdf6e3;color:#657b83;">pSet</span> that respect
equivalence, i.e. when the inputs are equivalent the output is as well.</p>
</div></div><div class="decl"><h4>Set</h4><div class="decl_par"><p>The ZFC universe of sets consists of the type of pre-sets,
quotiented by extensional equivalence.</p>
</div></div><div class="decl"><h4>pSet.resp.eval</h4><div class="decl_par"><p>An equivalence-respecting function yields an n-ary Set function.</p>
</div></div><div class="decl"><h4>pSet.definable</h4><div class="decl_par"><p>A set function is &quot;definable&quot; if it is the image of some n-ary pre-set
function. This isn't exactly definability, but is useful as a sufficient
condition for functions that have a computable image.</p>
</div></div><div class="decl"><h4>Set.to_set</h4><div class="decl_par"><p>Convert a ZFC set into a <span style="background-color:#fdf6e3;color:#657b83;">set</span> of sets</p>
</div></div><div class="decl"><h4>Set.empty</h4><div class="decl_par"><p>The empty set</p>
</div></div><div class="decl"><h4>Set.insert</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">insert x y</span> is the set <span style="background-color:#fdf6e3;color:#657b83;">{x} ∪ y</span></p>
</div></div><div class="decl"><h4>Set.omega</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">omega</span> is the first infinite von Neumann ordinal</p>
</div></div><div class="decl"><h4>Set.sep</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">{x ∈ a | p x}</span> is the set of elements in <span style="background-color:#fdf6e3;color:#657b83;">a</span> satisfying <span style="background-color:#fdf6e3;color:#657b83;">p</span></p>
</div></div><div class="decl"><h4>Set.powerset</h4><div class="decl_par"><p>The powerset operation, the collection of subsets of a set</p>
</div></div><div class="decl"><h4>Set.Union</h4><div class="decl_par"><p>The union operator, the collection of elements of elements of a set</p>
</div></div><div class="decl"><h4>Set.union</h4><div class="decl_par"><p>The binary union operation</p>
</div></div><div class="decl"><h4>Set.inter</h4><div class="decl_par"><p>The binary intersection operation</p>
</div></div><div class="decl"><h4>Set.diff</h4><div class="decl_par"><p>The set difference operation</p>
</div></div><div class="decl"><h4>Set.image</h4><div class="decl_par"><p>The image of a (definable) set function</p>
</div></div><div class="decl"><h4>Set.pair</h4><div class="decl_par"><p>Kuratowski ordered pair</p>
</div></div><div class="decl"><h4>Set.pair_sep</h4><div class="decl_par"><p>A subset of pairs <span style="background-color:#fdf6e3;color:#657b83;">{(a, b) ∈ x × y | p a b}</span></p>
</div></div><div class="decl"><h4>Set.prod</h4><div class="decl_par"><p>The cartesian product, <span style="background-color:#fdf6e3;color:#657b83;">{(a, b) | a ∈ x, b ∈ y}</span></p>
</div></div><div class="decl"><h4>Set.is_func</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">is_func x y f</span> is the assertion <span style="background-color:#fdf6e3;color:#657b83;">f : x </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span> where <span style="background-color:#fdf6e3;color:#657b83;">f</span> is a ZFC function
(a set of ordered pairs)</p>
</div></div><div class="decl"><h4>Set.funs</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">funs x y</span> is <span style="background-color:#fdf6e3;color:#657b83;">y ^ x</span>, the set of all set functions <span style="background-color:#fdf6e3;color:#657b83;">x </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> y</span></p>
</div></div><div class="decl"><h4>Set.map</h4><div class="decl_par"><p>Graph of a function: <span style="background-color:#fdf6e3;color:#657b83;">map f x</span> is the ZFC function which maps <span style="background-color:#fdf6e3;color:#657b83;">a ∈ x</span> to <span style="background-color:#fdf6e3;color:#657b83;">f a</span></p>
</div></div><div class="decl"><h4>Class.of_Set</h4><div class="decl_par"><p>Coerce a set into a class</p>
</div></div><div class="decl"><h4>Class.univ</h4><div class="decl_par"><p>The universal class</p>
</div></div><div class="decl"><h4>Class.to_Set</h4><div class="decl_par"><p>Assert that <span style="background-color:#fdf6e3;color:#657b83;">A</span> is a set satisfying <span style="background-color:#fdf6e3;color:#657b83;">p</span></p>
</div></div><div class="decl"><h4>Class.mem</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">A ∈ B</span> if <span style="background-color:#fdf6e3;color:#657b83;">A</span> is a set which is a member of <span style="background-color:#fdf6e3;color:#657b83;">B</span></p>
</div></div><div class="decl"><h4>Class.Cong_to_Class</h4><div class="decl_par"><p>Convert a conglomerate (a collection of classes) into a class</p>
</div></div><div class="decl"><h4>Class.Class_to_Cong</h4><div class="decl_par"><p>Convert a class into a conglomerate (a collection of classes)</p>
</div></div><div class="decl"><h4>Class.powerset</h4><div class="decl_par"><p>The power class of a class is the class of all subclasses that are sets</p>
</div></div><div class="decl"><h4>Class.Union</h4><div class="decl_par"><p>The union of a class is the class of all members of sets in the class</p>
</div></div><div class="decl"><h4>Class.iota</h4><div class="decl_par"><p>The definite description operator, which is {x} if <span style="background-color:#fdf6e3;color:#657b83;">{a | p a} </span><span style="background-color:#fdf6e3;color:#b58900;">=</span><span style="background-color:#fdf6e3;color:#657b83;"> {x}</span>
and ∅ otherwise</p>
</div></div><div class="decl"><h4>Class.iota_ex</h4><div class="decl_par"><p>Unlike the other set constructors, the <span style="background-color:#fdf6e3;color:#657b83;">iota</span> definite descriptor
is a set for any set input, but not constructively so, so there is no
associated <span style="background-color:#fdf6e3;color:#657b83;">(Set </span><span style="background-color:#fdf6e3;color:#859900;">→ </span><span style="background-color:#fdf6e3;color:#268bd2;">Prop</span><span style="background-color:#fdf6e3;color:#657b83;">) </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> Set</span> function.</p>
</div></div><div class="decl"><h4>Class.fval</h4><div class="decl_par"><p>Function value</p>
</div></div><div class="decl"><h4>Set.choice</h4><div class="decl_par"><p>A choice function on the set of nonempty sets <span style="background-color:#fdf6e3;color:#657b83;">x</span></p>
</div></div></html>