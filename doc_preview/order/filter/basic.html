<html><head><link rel="stylesheet" href="../../docs_style.css"></head><div class="decl"><h4>filter.has_mem</h4><div class="decl_par"><p>If <span style="background-color:#fdf6e3;color:#657b83;">F</span> is a filter on <span style="background-color:#fdf6e3;color:#657b83;">α</span>, and <span style="background-color:#fdf6e3;color:#657b83;">U</span> a subset of <span style="background-color:#fdf6e3;color:#657b83;">α</span> then we can write <span style="background-color:#fdf6e3;color:#657b83;">U ∈ F</span> as on paper.</p>
</div></div><div class="decl"><h4>tactic.interactive.filter_upwards</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">filter_upwards [h1, ⋯, hn]</span> replaces a goal of the form <span style="background-color:#fdf6e3;color:#657b83;">s ∈ f</span>
and terms <span style="background-color:#fdf6e3;color:#657b83;">h1 : t1 ∈ f, ⋯, hn : tn ∈ f</span> with <span style="background-color:#fdf6e3;color:#657b83;">∀x, x ∈ t1 </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> ⋯ </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> x ∈ tn </span><span style="background-color:#fdf6e3;color:#859900;">→</span><span style="background-color:#fdf6e3;color:#657b83;"> x ∈ s</span>.</p>
<p><span style="background-color:#fdf6e3;color:#657b83;">filter_upwards [h1, ⋯, hn] e</span> is a short form for <span style="background-color:#fdf6e3;color:#657b83;">{ filter_upwards [h1, ⋯, hn], exact e }</span>.</p>
</div></div><div class="decl"><h4>filter.principal</h4><div class="decl_par"><p>The principal filter of <span style="background-color:#fdf6e3;color:#657b83;">s</span> is the collection of all supersets of <span style="background-color:#fdf6e3;color:#657b83;">s</span>.</p>
</div></div><div class="decl"><h4>filter.join</h4><div class="decl_par"><p>The join of a filter of filters is defined by the relation <span style="background-color:#fdf6e3;color:#657b83;">s ∈ join f </span><span style="background-color:#fdf6e3;color:#b58900;">↔</span><span style="background-color:#fdf6e3;color:#657b83;"> {t | s ∈ t} ∈ f</span>.</p>
</div></div><div class="decl"><h4>filter.generate_sets</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">generate_sets g s</span>: <span style="background-color:#fdf6e3;color:#657b83;">s</span> is in the filter closure of <span style="background-color:#fdf6e3;color:#657b83;">g</span>.</p>
</div></div><div class="decl"><h4>filter.generate</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">generate g</span> is the smallest filter containing the sets <span style="background-color:#fdf6e3;color:#657b83;">g</span>.</p>
</div></div><div class="decl"><h4>filter.lattice.has_inf</h4><div class="decl_par"><p>The infimum of filters is the filter generated by intersections
of elements of the two filters.</p>
</div></div><div class="decl"><h4>filter.map</h4><div class="decl_par"><p>The forward map of a filter</p>
</div></div><div class="decl"><h4>filter.comap</h4><div class="decl_par"><p>The inverse map of a filter</p>
</div></div><div class="decl"><h4>filter.cofinite</h4><div class="decl_par"><p>The cofinite filter is the filter of subsets whose complements are finite.</p>
</div></div><div class="decl"><h4>filter.bind</h4><div class="decl_par"><p>The monadic bind operation on filter is defined the usual way in terms of <span style="background-color:#fdf6e3;color:#657b83;">map</span> and <span style="background-color:#fdf6e3;color:#657b83;">join</span>.</p>
<p>Unfortunately, this <span style="background-color:#fdf6e3;color:#657b83;">bind</span> does not result in the expected applicative. See <span style="background-color:#fdf6e3;color:#657b83;">filter.seq</span> for the
applicative instance.</p>
</div></div><div class="decl"><h4>filter.seq</h4><div class="decl_par"><p>The applicative sequentiation operation. This is not induced by the bind operation.</p>
</div></div><div class="decl"><h4>filter.tendsto</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">tendsto</span> is the generic &quot;limit of a function&quot; predicate.
<span style="background-color:#fdf6e3;color:#657b83;">tendsto f l₁ l₂</span> asserts that for every <span style="background-color:#fdf6e3;color:#657b83;">l₂</span> neighborhood <span style="background-color:#fdf6e3;color:#657b83;">a</span>,
the <span style="background-color:#fdf6e3;color:#657b83;">f</span>-preimage of <span style="background-color:#fdf6e3;color:#657b83;">a</span> is an <span style="background-color:#fdf6e3;color:#657b83;">l₁</span> neighborhood.</p>
</div></div><div class="decl"><h4>filter.prod</h4><div class="decl_par"><p>Product of filters. This is the filter generated by cartesian products
of elements of the component filters.</p>
</div></div><div class="decl"><h4>filter.at_top</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">at_top</span> is the filter representing the limit <span style="background-color:#fdf6e3;color:#657b83;">→ ∞</span> on an ordered set.
It is generated by the collection of up-sets <span style="background-color:#fdf6e3;color:#657b83;">{b | a </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> b}</span>.
(The preorder need not have a top element for this to be well defined,
and indeed is trivial when a top element exists.)</p>
</div></div><div class="decl"><h4>filter.at_bot</h4><div class="decl_par"><p><span style="background-color:#fdf6e3;color:#657b83;">at_bot</span> is the filter representing the limit <span style="background-color:#fdf6e3;color:#657b83;">→ </span><span style="background-color:#fdf6e3;color:#b58900;">-</span><span style="background-color:#fdf6e3;color:#657b83;">∞</span> on an ordered set.
It is generated by the collection of down-sets <span style="background-color:#fdf6e3;color:#657b83;">{b | b </span><span style="background-color:#fdf6e3;color:#b58900;">≤</span><span style="background-color:#fdf6e3;color:#657b83;"> a}</span>.
(The preorder need not have a bottom element for this to be well defined,
and indeed is trivial when a bottom element exists.)</p>
</div></div><div class="decl"><h4>filter.tendsto_at_top_embedding</h4><div class="decl_par"><p>A function <span style="background-color:#fdf6e3;color:#657b83;">f</span> grows to infinity independent of an order-preserving embedding <span style="background-color:#fdf6e3;color:#657b83;">e</span>.</p>
</div></div><div class="decl"><h4>filter.map_at_top_eq_of_gc</h4><div class="decl_par"><p>A function <span style="background-color:#fdf6e3;color:#657b83;">f</span> maps upwards closed sets (at_top sets) to upwards closed sets when it is a
Galois insertion. The Galois &quot;insertion&quot; and &quot;connection&quot; is weakened to only require it to be an
insertion and a connetion above <span style="background-color:#fdf6e3;color:#657b83;">b&#39;</span>.</p>
</div></div><div class="decl"><h4>filter.is_ultrafilter</h4><div class="decl_par"><p>An ultrafilter is a minimal (maximal in the set order) proper filter.</p>
</div></div><div class="decl"><h4>filter.ultrafilter_iff_compl_mem_iff_not_mem</h4><div class="decl_par"><p>Equivalent characterization of ultrafilters:
A filter f is an ultrafilter if and only if for each set s,
-s belongs to f if and only if s does not belong to f.</p>
</div></div><div class="decl"><h4>filter.exists_ultrafilter</h4><div class="decl_par"><p>The ultrafilter lemma: Any proper filter is contained in an ultrafilter.</p>
</div></div><div class="decl"><h4>filter.ultrafilter_of</h4><div class="decl_par"><p>Construct an ultrafilter extending a given filter.
The ultrafilter lemma is the assertion that such a filter exists;
we use the axiom of choice to pick one.</p>
</div></div><div class="decl"><h4>filter.sup_of_ultrafilters</h4><div class="decl_par"><p>A filter equals the intersection of all the ultrafilters which contain it.</p>
</div></div><div class="decl"><h4>filter.tendsto_iff_ultrafilter</h4><div class="decl_par"><p>The <span style="background-color:#fdf6e3;color:#657b83;">tendsto</span> relation can be checked on ultrafilters.</p>
</div></div></html>