<html><head><link rel="stylesheet" href="../../../docs_style.css"></head><h1>The category of commutative rings has all limits</h1>
<p>Further, these limits are preserved by the forgetful functor --- that is,
the underlying types are just the limits in the category of types.</p>
<h2>Further work</h2>
<p>A lot of this should be generalised / automated, as it's quite common for concrete
categories that the forgetful functor preserves limits.</p>
<hr/><div class="decl"><h4>CommRing.CommRing_has_limits.limit</h4><div class="decl_par"><p>Construction of a limit cone in <span style="background-color:#fdf6e3;color:#657b83;">CommRing</span>.
(Internal use only; use the limits API.)</p>
</div></div><div class="decl"><h4>CommRing.CommRing_has_limits.limit_is_limit</h4><div class="decl_par"><p>Witness that the limit cone in <span style="background-color:#fdf6e3;color:#657b83;">CommRing</span> is a limit cone.
(Internal use only; use the limits API.)</p>
</div></div><div class="decl"><h4>CommRing.CommRing_has_limits</h4><div class="decl_par"><p>The category of commutative rings has all limits.</p>
</div></div><div class="decl"><h4>CommRing.forget_preserves_limits</h4><div class="decl_par"><p>The forgetful functor from commutative rings to types preserves all limits. (That is, the underlying
types could have been computed instead as limits in the category of types.)</p>
</div></div></html>