<html><head><link rel="stylesheet" href="../../docs_style.css"></head><h1>Transport multiplicative to additive</h1>
<p>This file defines an attribute <span style="background-color:#fdf6e3;color:#657b83;">to_additive</span> that can be used to
automatically transport theorems and definitions (but not inductive
types and structures) from multiplicative theory to additive theory.</p>
<p>To use this attribute, just write</p>
<pre><code class="language-lean"><pre style="background-color:#fdf6e3;">
<span style="color:#586e75;">@[to_additive]
</span><span style="color:#859900;">theorem </span><span style="color:#d33682;">mul_comm&#39; </span><span style="color:#657b83;">{α} [comm_semigroup α] (x y : α) : x </span><span style="color:#b58900;">*</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">=</span><span style="color:#657b83;"> y </span><span style="color:#b58900;">*</span><span style="color:#657b83;"> x </span><span style="color:#b58900;">:=</span><span style="color:#657b83;"> comm_semigroup.mul_comm
</span></pre>
</code></pre>
<p>This code will generate a theorem named <span style="background-color:#fdf6e3;color:#657b83;">add_comm&#39;</span>.  It is also
possible to manually specify the name of the new declaration, and
provide a documentation string.</p>
<p>The transport tries to do the right thing in most cases using several
heuristics described below.  However, in some cases it fails, and
requires manual intervention.</p>
<h2>Implementation notes</h2>
<h3>Handling of hidden definitions</h3>
<p>Before transporting the “main” declaration <span style="background-color:#fdf6e3;color:#657b83;">src</span>, <span style="background-color:#fdf6e3;color:#657b83;">to_additive</span> first
scans its type and value for names starting with <span style="background-color:#fdf6e3;color:#657b83;">src</span>, and transports
them. This includes auxiliary definitions like <span style="background-color:#fdf6e3;color:#657b83;">src._match_1</span>,
<span style="background-color:#fdf6e3;color:#657b83;">src._proof_1</span>.</p>
<p>After transporting the “main” declaration, <span style="background-color:#fdf6e3;color:#657b83;">to_additive</span> transports
its equational lemmas.</p>
<h3>Structure fields and constructors</h3>
<p>If <span style="background-color:#fdf6e3;color:#657b83;">src</span> is a structure, then <span style="background-color:#fdf6e3;color:#657b83;">to_additive</span> automatically adds
structure fields to its mapping, and similarly for constructors of
inductive types.</p>
<p>For new structures this means that <span style="background-color:#fdf6e3;color:#657b83;">to_additive</span> automatically handles
coercions, and for old structures it does the same, if ancestry
information is present in <span style="background-color:#fdf6e3;color:#586e75;">@[ancestor]</span> attributes.</p>
<h3>Name generation</h3>
<ul>
<li>
<p>If <span style="background-color:#fdf6e3;color:#586e75;">@[to_additive]</span> is called without a <span style="background-color:#fdf6e3;color:#657b83;">name</span> argument, then the
new name is autogenerated.  First, it takes the longest prefix of
the source name that is already known to <span style="background-color:#fdf6e3;color:#657b83;">to_additive</span>, and replaces
this prefix with its additive counterpart. Second, it takes the last
part of the name (i.e., after the last dot), and replaces common
name parts (“mul”, “one”, “inv”, “prod”) with their additive versions.</p>
</li>
<li>
<p>If <span style="background-color:#fdf6e3;color:#586e75;">@[to_additive]</span> is called with a <span style="background-color:#fdf6e3;color:#657b83;">name</span> argument <span style="background-color:#fdf6e3;color:#657b83;">new_name</span>
/without a dot/, then <span style="background-color:#fdf6e3;color:#657b83;">to_additive</span> updates the prefix as described
above, then replaces the last part of the name with <span style="background-color:#fdf6e3;color:#657b83;">new_name</span>.</p>
</li>
<li>
<p>If <span style="background-color:#fdf6e3;color:#586e75;">@[to_additive]</span> is called with a <span style="background-color:#fdf6e3;color:#657b83;">name</span> argument
<span style="background-color:#fdf6e3;color:#657b83;">new_namespace.new_name</span> /with a dot/, then <span style="background-color:#fdf6e3;color:#657b83;">to_additive</span> uses this
new name as is.</p>
</li>
</ul>
<p>As a safety check, in the first two cases <span style="background-color:#fdf6e3;color:#657b83;">to_additive</span> double checks
that the new name differs from the original one.</p>
<h3>Missing features</h3>
<ul>
<li>
<p>Automatically transport structures and other inductive types.</p>
</li>
<li>
<p>Handle <span style="background-color:#fdf6e3;color:#859900;">protected</span> attribute. Currently all new definitions are public.</p>
</li>
<li>
<p>For structures, automatically generate theorems like <span style="background-color:#fdf6e3;color:#657b83;">group α </span><span style="background-color:#fdf6e3;color:#b58900;">↔</span><span style="background-color:#fdf6e3;color:#657b83;"> add_group (additive α)</span>.</p>
</li>
<li>
<p>Mapping of prefixes that do not correspond to any definition, see
<span style="background-color:#fdf6e3;color:#657b83;">quotient_group</span>.</p>
</li>
<li>
<p>Rewrite rules for the last part of the name that work in more
cases. E.g., we can replace <span style="background-color:#fdf6e3;color:#657b83;">monoid</span> with <span style="background-color:#fdf6e3;color:#657b83;">add_monoid</span> etc.</p>
</li>
</ul>
<hr/></html>